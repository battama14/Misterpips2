<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard Trading</title>
    <link rel="stylesheet" href="dashboard-styles.css">
    <link rel="stylesheet" href="vip-styles-new.css">
    <link rel="stylesheet" href="mobile-responsive.css">
    <link rel="stylesheet" href="ict-matrix-styles.css">
    <link rel="stylesheet" href="chat-mobile-styles.css">
    <link rel="stylesheet" href="chat-optimized.css">
    <link rel="stylesheet" href="mobile-fixes.css">
    <link rel="stylesheet" href="imessage-chat.css">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#00d4ff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Misterpips">
    <link rel="apple-touch-icon" href="Misterpips.jpg">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js';
        import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.0/firebase-auth.js';
        import { getDatabase, ref, set, get, onValue, push } from 'https://www.gstatic.com/firebasejs/10.7.0/firebase-database.js';
        import { getMessaging, getToken, onMessage } from 'https://www.gstatic.com/firebasejs/10.7.0/firebase-messaging.js';
        
        const firebaseConfig = {
            apiKey: "AIzaSyDSDK0NfVSs_VQb3TnrixiJbOpTsmoUMvU",
            authDomain: "misterpips-b71fb.firebaseapp.com",
            databaseURL: "https://misterpips-b71fb-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "misterpips-b71fb",
            storageBucket: "misterpips-b71fb.firebasestorage.app",
            messagingSenderId: "574231126409",
            appId: "1:574231126409:web:b7ed93ac4ea62e247dc158"
        };
        
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getDatabase(app);
        const messaging = getMessaging(app);
        
        // Activer Firebase avec authentification existante
        window.firebaseDB = db;
        window.firebaseAuth = auth;
        
        // Vérifier l'authentification existante
        onAuthStateChanged(auth, (user) => {
            if (!user) {
                // Rediriger vers la page de connexion si pas connecté
                window.location.href = 'index-fixed.html';
            } else {
                console.log('Utilisateur connecté:', user.email, user.uid);
                // Définir l'utilisateur pour le dashboard
                sessionStorage.setItem('firebaseUID', user.uid);
                sessionStorage.setItem('userEmail', user.email);
                

            }
        });

    </script>

</head>
<body>
    <script>
        // Initialisation avec utilisateur authentifié
        window.addEventListener('DOMContentLoaded', function() {
            // Attendre l'authentification Firebase
            const checkAuth = setInterval(() => {
                const firebaseUID = sessionStorage.getItem('firebaseUID');
                const userEmail = sessionStorage.getItem('userEmail');
                
                if (firebaseUID && userEmail) {
                    sessionStorage.setItem('currentUser', firebaseUID);
                    sessionStorage.setItem('authenticated', 'true');
                    
                    // Afficher l'email de l'utilisateur
                    document.querySelector('header h1').innerHTML = `Dashboard Trading <span style="font-size: 0.6em; opacity: 0.7;">- ${userEmail}</span>`;
                    
                    clearInterval(checkAuth);
                }
            }, 100);
        });
    </script>
    
    <div class="container">
        <header>
            <h1>Dashboard Trading</h1>
            <button id="mobileMenuBtn" class="mobile-menu-btn">☰</button>
            <nav class="mobile-nav" id="mobileNav">
                <ul class="nav-links" id="navLinks">
                    <li><a href="vip-space.html">🏠 Accueil VIP</a></li>
                    <li><a href="trading-dashboard.html">📊 Dashboard</a></li>
                    <li><a href="#" onclick="document.getElementById('newTradeBtn').click()">➕ Nouveau Trade</a></li>
                    <li><a href="#" onclick="document.getElementById('historyTradeBtn').click()">📅 Trade Passé</a></li>
                    <li><a href="#" onclick="document.getElementById('settingsBtn').click()">⚙️ Paramètres</a></li>
                    <li><a href="#" onclick="document.getElementById('exportBtn').click()">📊 Export Excel</a></li>
                    <li><a href="index.html">🚪 Déconnexion</a></li>
                </ul>
            </nav>
            <div id="navOverlay" class="nav-overlay"></div>
            <div class="account-selector">
                <label for="accountSelect">💼 Compte:</label>
                <select id="accountSelect">
                    <option value="compte1">Compte Principal</option>
                    <option value="compte2">Compte Démo</option>
                    <option value="compte3">Compte Swing</option>
                </select>
                <button id="addAccountBtn" class="btn-info" style="padding: 5px 10px; margin-left: 10px;">+ Nouveau</button>
                <button id="deleteAccountBtn" class="btn-danger" style="padding: 5px 10px; margin-left: 5px;">🗑️</button>
                <div id="syncStatus" style="margin-left: 10px; padding: 5px 10px; border-radius: 5px; font-size: 0.8em; background: rgba(78,205,196,0.2); color: #4ecdc4;">🔄 Sync Auto</div>
            </div>
            <div class="stats-overview">
                <div class="stat-card">
                    <h3>Capital</h3>
                    <span id="capital">$1000</span>
                </div>
                <div class="stat-card">
                    <h3>Winrate</h3>
                    <span id="winRate">0%</span>
                </div>
                <div class="stat-card">
                    <h3>P&L Total</h3>
                    <span id="totalPnL">$0</span>
                </div>
                <div class="stat-card">
                    <h3>Trades Ouverts</h3>
                    <span id="openTrades">0</span>
                </div>
                <div class="stat-card">
                    <h3>Total Trades</h3>
                    <span id="totalTrades">0</span>
                </div>
            </div>
        </header>

        <main>
            <div class="actions">
                <button id="newTradeBtn" class="btn-primary">Nouveau Trade</button>
                <button id="historyTradeBtn" class="btn-success">📅 TRADE PASSÉ</button>
                <button id="settingsBtn" class="btn-secondary">⚙️ Paramètres</button>
                <button id="closeTradeBtn" class="btn-warning">Clôturer Trade</button>
                <button id="resetBtn" class="btn-danger">Reset Données</button>
                <button id="manualCloseBtn" class="btn-warning">🎯 Clôture Manuelle</button>
                <button id="exportBtn" class="btn-info">📊 Export Excel</button>
            </div>

            <div class="charts-section">
                <div class="chart-container" style="height: 350px; padding: 25px;">
                    <h3>📈 Performance Cumulative</h3>
                    <canvas id="performanceChart" style="max-height: 250px;"></canvas>
                </div>
                <div class="chart-container" style="height: 350px; padding: 25px; display: flex; flex-direction: column; justify-content: center;">
                    <h3>🎯 Taux de Réussite</h3>
                    <div style="height: 220px; display: flex; align-items: center; justify-content: center;">
                        <canvas id="winRateChart" style="max-width: 180px; max-height: 180px;"></canvas>
                    </div>
                </div>
                <div class="chart-container" style="height: 350px; padding: 25px;">
                    <h3>📊 Performance Mensuelle</h3>
                    <canvas id="monthlyChart" style="max-height: 250px;"></canvas>
                </div>
            </div>
            
            <div class="charts-section">
                <div class="chart-container" style="height: 500px; padding: 25px;">
                    <div class="gauge-container">
                        <h3>💰 Performance Totale</h3>
                        <div id="gainsGauge" class="gauge" style="width: 160px; height: 160px; margin: 15px auto;"></div>
                        <div id="gainsValue" class="gauge-value">$0</div>
                        <div id="gainsPercent" class="gauge-percent">0%</div>
                    </div>
                </div>
                <div class="chart-container" style="height: 500px; padding: 25px;">
                    <h3>📊 Analyse des Confluences</h3>
                    <canvas id="confluencesChart" style="max-height: 180px;"></canvas>
                    <div id="confluenceAnalysis" class="confluence-analysis" style="margin-top: 10px;">
                        <h4>🔍 Analyse des Confluences ICT</h4>
                        <div class="analysis-item">
                            <span class="confluence-name">Contexte Global</span>
                            <span class="confluence-score score-excellent">Excellent</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="chart-container" style="margin-top: 30px; padding: 25px; height: 900px;">
                <h3>🔗 Matrice de Corrélation ICT - Étapes de Trading</h3>
                <div class="dashboard-card correlation-card">
                    <div class="card-header">
                        <h3><i class="fas fa-brain"></i> Analyse ICT en Temps Réel</h3>
                        <div class="refresh-btn" id="refreshCorrelations">
                            <i class="fas fa-sync-alt"></i>
                        </div>
                    </div>
                    <div class="correlation-matrix" id="correlationMatrix">
                        <!-- Matrice générée dynamiquement -->
                    </div>
                </div>
            </div>

            <!-- Plan de Trading avec Objectifs -->
            <div class="trading-plan-section">
                <h2>🎯 Plan de Trading & Objectifs</h2>
                <div class="plan-stats">
                    <div class="plan-card">
                        <h4>☀️ Objectif Journalier</h4>
                        <div class="target-info">
                            <div class="target-amount">Cible: <span id="dailyTargetPercent">1%</span> : $<span id="dailyTarget">10</span></div>
                            <div class="target-progress">
                                <div class="progress-bar">
                                    <div class="progress-fill" id="dailyProgressBar" style="width: 0%"></div>
                                </div>
                                <span id="dailyProgress">0%</span>
                            </div>
                        </div>
                    </div>
                    <div class="plan-card">
                        <h4>📊 Objectif Mensuel</h4>
                        <div class="target-info">
                            <div class="target-amount">Cible: <span id="monthlyTargetPercent">15%</span> : $<span id="monthlyTarget">150</span></div>
                            <div class="target-progress">
                                <div class="progress-bar">
                                    <div class="progress-fill" id="monthlyProgressBar" style="width: 0%"></div>
                                </div>
                                <span id="monthProgress">0%</span>
                            </div>
                        </div>
                    </div>
                    <div class="plan-card">
                        <h4>📅 Objectif Hebdomadaire</h4>
                        <div class="target-info">
                            <div class="target-amount">Cible: <span id="weeklyTargetPercent">3%</span> : $<span id="weeklyTarget">30</span></div>
                            <div class="target-progress">
                                <div class="progress-bar">
                                    <div class="progress-fill" id="weeklyProgressBar" style="width: 0%"></div>
                                </div>
                                <span id="weekProgress">0%</span>
                            </div>
                        </div>
                    </div>
                    <div class="plan-card">
                        <h4>🎯 Objectif Annuel</h4>
                        <div class="target-info">
                            <div class="target-amount">Cible: <span id="yearlyTargetPercent">200%</span> : $<span id="yearlyTarget">2000</span></div>
                            <div class="target-progress">
                                <div class="progress-bar">
                                    <div class="progress-fill" id="yearlyProgressBar" style="width: 0%"></div>
                                </div>
                                <span id="yearProgress">0%</span>
                            </div>
                        </div>
                    </div>
                    <div class="plan-card">
                        <h4>📈 Rendement Annuel</h4>
                        <div class="return-info">
                            <div class="return-value" id="yearReturn">0%</div>
                            <div class="return-label">du capital initial</div>
                        </div>
                    </div>
                    
                    <!-- Classement VIP en Temps Réel -->
                    <div class="plan-card">
                        <h4>🏆 Classement VIP Journalier</h4>
                        <div class="vip-ranking-content">

                            <div class="ranking-list" id="rankingList">
                                <!-- Le classement sera chargé ici -->
                            </div>
                        </div>
                    </div>
                    

                </div>
            </div>

            <!-- Calendrier de Trading -->
            <div class="calendar-section">
                <h2>📅 Calendrier de Trading</h2>
                <div class="calendar-wrapper">
                    <div class="calendar-controls">
                        <button id="prevMonth" class="btn-secondary">◀</button>
                        <div id="monthYear" class="month-label">Mois</div>
                        <button id="nextMonth" class="btn-secondary">▶</button>
                    </div>
                    <div class="calendar-grid-container">
                        <div id="calendarGrid" class="calendar-grid">
                            <!-- Le calendrier sera généré ici -->
                        </div>
                    </div>
                    <div class="calendar-stats">
                        <div class="calendar-stat">
                            <h4>📊 Ce Mois</h4>
                            <div class="stat-value" id="monthPnL">$0</div>
                            <div class="stat-label">WinRate: <span id="monthWinRate">0%</span></div>
                        </div>
                        <div class="calendar-stat">
                            <h4>📈 Cette Année</h4>
                            <div class="stat-value" id="yearPnL">$0</div>
                            <div class="stat-label">WinRate: <span id="yearWinRate">0%</span></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="trades-history">
                <h2>Historique des Trades</h2>
                <table id="tradesTable">
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>Devise</th>
                            <th>Entrée</th>
                            <th>SL</th>
                            <th>TP</th>
                            <th>Lot</th>
                            <th>Risque %</th>
                            <th>Risque Réel</th>
                            <th>Résultat</th>
                            <th>Gain/Perte</th>
                            <th>Actions</th>
                            <th>Modifier</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </main>
    </div>

    <!-- Modal Nouveau Trade -->
    <div id="tradeModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <div id="modalContent"></div>
        </div>
    </div>

    <!-- Modal Plein Écran pour Graphiques -->
    <div id="fullscreenModal" class="modal fullscreen-modal">
        <div class="fullscreen-content" id="fullscreenContent">
            <span class="close-fullscreen">&times;</span>
        </div>
    </div>

    <!-- Modal Trade Passé -->
    <div id="historyTradeModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>📅 Ajouter un Trade Passé</h3>
                <span class="close" onclick="closeHistoryModal()">&times;</span>
            </div>
            <div class="modal-body">
                <form id="historyTradeForm">
                    <div class="form-row">
                        <div class="form-group">
                            <label>Date du Trade</label>
                            <input type="date" id="tradeDate" required>
                        </div>
                        <div class="form-group">
                            <label>Paire</label>
                            <select id="tradePair" required>
                                <option value="EUR/USD">EUR/USD</option>
                                <option value="GBP/USD">GBP/USD</option>
                                <option value="USD/JPY">USD/JPY</option>
                                <option value="AUD/USD">AUD/USD</option>
                                <option value="USD/CHF">USD/CHF</option>
                                <option value="NZD/USD">NZD/USD</option>
                                <option value="USD/CAD">USD/CAD</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Type</label>
                            <select id="tradeType" required>
                                <option value="BUY">BUY</option>
                                <option value="SELL">SELL</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Taille (lots)</label>
                            <input type="number" id="tradeSize" step="0.01" min="0.01" required>
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Prix d'Entrée</label>
                            <input type="number" id="entryPrice" step="0.00001" required>
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Résultat Final</label>
                            <select id="tradeResult" required>
                                <option value="TP">Take Profit (TP)</option>
                                <option value="SL">Stop Loss (SL)</option>
                                <option value="BE">Break Even (BE)</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>P&L ($)</label>
                            <input type="number" id="tradePnL" step="0.01" placeholder="Sera calculé automatiquement">
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Stop Loss</label>
                            <input type="number" id="stopLoss" step="0.00001" required>
                        </div>
                        <div class="form-group">
                            <label>Take Profit</label>
                            <input type="number" id="takeProfit" step="0.00001" required>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Notes (optionnel)</label>
                        <textarea id="tradeNotes" placeholder="Analyse du trade..."></textarea>
                    </div>
                    <div class="form-actions">
                        <button type="button" onclick="closeHistoryModal()" class="btn-secondary">Annuler</button>
                        <button type="button" class="btn-primary" onclick="addHistoryTrade()">Ajouter le Trade</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <script src="simple-vip-security.js"></script>
    <script src="mobile-menu-complete.js"></script>
    <script src="mobile-optimizations.js"></script>
    <script src="dashboard-script-working.js"></script>
    <script src="imessage-chat.js"></script>
    
    <script>
        // Initialiser le chat après le chargement de la page
        document.addEventListener('DOMContentLoaded', function() {
            // Attendre que Firebase soit initialisé
            setTimeout(() => {
                console.log('🚀 Initialisation du chat iMessage...');
                
                // Initialiser les fonctionnalités du chat
                if (typeof initEmojiPicker === 'function') {
                    initEmojiPicker();
                }
                if (typeof initFileUpload === 'function') {
                    initFileUpload();
                }
                if (typeof initGifSearch === 'function') {
                    initGifSearch();
                }
                if (typeof initChatEnhancements === 'function') {
                    initChatEnhancements();
                }
                
                console.log('✅ Chat iMessage initialisé');
            }, 2000);
        });
    </script>

    <script>
        document.getElementById('historyTradeBtn').addEventListener('click', () => {
            const modal = document.getElementById('historyTradeModal');
            const dateInput = document.getElementById('tradeDate');
            
            modal.style.display = 'block';
            
            // Triple vérification pour s'assurer que la date est correcte
            const setTodayDate = () => {
                const today = new Date();
                const localDate = new Date(today.getTime() - (today.getTimezoneOffset() * 60000));
                const dateString = localDate.toISOString().split('T')[0];
                dateInput.value = dateString;
                console.log('Date définie:', dateString);
            };
            
            // Définir immédiatement
            setTodayDate();
            
            // Vérifier après un court délai
            setTimeout(() => {
                if (!dateInput.value) {
                    setTodayDate();
                }
            }, 100);
            
            // Focus sur le premier champ
            setTimeout(() => {
                dateInput.focus();
            }, 200);
        });

        function closeHistoryModal() {
            document.getElementById('historyTradeModal').style.display = 'none';
            document.getElementById('historyTradeForm').reset();
        }
        
        window.closeHistoryModal = closeHistoryModal;

        function calculatePnL() {
            const entryPrice = parseFloat(document.getElementById('entryPrice').value);
            const stopLoss = parseFloat(document.getElementById('stopLoss').value);
            const takeProfit = parseFloat(document.getElementById('takeProfit').value);
            const size = parseFloat(document.getElementById('tradeSize').value);
            const type = document.getElementById('tradeType').value;
            const pair = document.getElementById('tradePair').value;
            const result = document.getElementById('tradeResult').value;

            if (entryPrice && stopLoss && takeProfit && size && result) {
                let exitPrice = 0;
                
                // Déterminer le prix de sortie selon le résultat
                if (result === 'TP') {
                    exitPrice = takeProfit;
                } else if (result === 'SL') {
                    exitPrice = stopLoss;
                } else if (result === 'BE') {
                    exitPrice = entryPrice;
                }
                
                let pnl = 0;
                
                // Calcul du P&L
                if (type === 'BUY') {
                    pnl = (exitPrice - entryPrice) * size * 100000;
                } else {
                    pnl = (entryPrice - exitPrice) * size * 100000;
                }
                
                // Ajustement pour les paires JPY
                if (pair.includes('JPY')) {
                    pnl = pnl / 100;
                }
                
                document.getElementById('tradePnL').value = pnl.toFixed(2);
            }
        }

        ['entryPrice', 'stopLoss', 'takeProfit', 'tradeSize', 'tradeType', 'tradePair', 'tradeResult'].forEach(id => {
            document.getElementById(id).addEventListener('input', calculatePnL);
            document.getElementById(id).addEventListener('change', calculatePnL);
        });

        function addHistoryTrade() {
            console.log('addHistoryTrade called');
            
            try {
                const entryPrice = parseFloat(document.getElementById('entryPrice').value);
                const stopLoss = parseFloat(document.getElementById('stopLoss').value);
                const takeProfit = parseFloat(document.getElementById('takeProfit').value);
                const result = document.getElementById('tradeResult').value;
                
                let closePrice = entryPrice;
                if (result === 'TP') closePrice = takeProfit;
                if (result === 'SL') closePrice = stopLoss;
                
                // Utiliser la date sélectionnée ou la date du jour
                const selectedDate = document.getElementById('tradeDate').value;
                const tradeDate = selectedDate || new Date().toLocaleDateString('en-CA'); // Format YYYY-MM-DD
                
                const tradeData = {
                    id: `trader_vip_${Date.now()}`,
                    date: tradeDate,
                    currency: document.getElementById('tradePair').value,
                    type: document.getElementById('tradeType').value,
                    lotSize: parseFloat(document.getElementById('tradeSize').value),
                    entryPoint: entryPrice,
                    stopLoss: stopLoss,
                    takeProfit: takeProfit,
                    closePrice: closePrice,
                    pnl: parseFloat(document.getElementById('tradePnL').value),
                    result: result,
                    notes: document.getElementById('tradeNotes').value,
                    status: 'closed',
                    createdAt: Date.now(),
                    isHistorical: true,
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
                };

                console.log('Trade data:', tradeData);
                console.log('Dashboard exists:', !!window.dashboard);

                if (window.dashboard) {
                    window.dashboard.trades.push(tradeData);
                    window.dashboard.saveData();
                    window.dashboard.updateStats();
                    window.dashboard.renderTradesTable();
                    window.dashboard.renderCalendar();
                    
                    // Synchroniser vers Firebase
                    syncTradesToFirebase();
                    
                    // Détruire tous les graphiques Chart.js existants
                    Object.values(Chart.instances).forEach(chart => chart.destroy());
                    
                    // Recréer les graphiques
                    setTimeout(() => {
                        window.dashboard.initCharts();
                        window.dashboard.initGauge();
                        window.dashboard.updateCalendarStats();
                    }, 100);
                    
                    console.log('Dashboard updated');
                }
                
                console.log('Closing modal');
                const modal = document.getElementById('historyTradeModal');
                const form = document.getElementById('historyTradeForm');
                
                if (modal) {
                    modal.style.display = 'none';
                    console.log('Modal closed');
                }
                
                if (form) {
                    form.reset();
                    console.log('Form reset');
                }
                
                alert('Trade passé ajouté!');
                
            } catch (error) {
                console.error('Error in addHistoryTrade:', error);
                alert('Erreur: ' + error.message);
            }
        }
        
        window.addHistoryTrade = addHistoryTrade;
        
        // Fonction utilitaire pour obtenir la date locale
        function getTodayLocalDate() {
            const today = new Date();
            const year = today.getFullYear();
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const day = String(today.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }
        
        // Fonction pour synchroniser les dates avec Firebase
        async function syncDateWithFirebase() {
            try {
                if (window.firebaseDB) {
                    const { ref, set } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-database.js');
                    const dateRef = ref(window.firebaseDB, 'system/currentDate');
                    await set(dateRef, {
                        date: getTodayLocalDate(),
                        timestamp: Date.now(),
                        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
                    });
                }
            } catch (error) {
                console.error('Erreur sync date Firebase:', error);
            }
        }
        
        // Synchroniser la date au chargement
        syncDateWithFirebase();

        window.addEventListener('click', (e) => {
            const modal = document.getElementById('historyTradeModal');
            if (e.target === modal) {
                closeHistoryModal();
            }
        });
    </script>

    <style>
        /* CSS EMOJI PANEL - ULTRA SIMPLE */
        .emoji-picker-panel {
            position: absolute !important;
            bottom: 50px !important;
            left: 0 !important;
            width: 300px !important;
            max-height: 400px !important;
            background: #1a1a2e !important;
            border: 2px solid #00d4ff !important;
            border-radius: 10px !important;
            z-index: 9999 !important;
            display: none !important;
            overflow: hidden !important;
        }
        
        /* CHAT MOBILE OPTIMISATIONS */
        @media (max-width: 768px) {
            .chat-fullscreen-btn {
                display: block !important;
                background: none;
                border: none;
                color: #00d4ff;
                font-size: 16px;
                cursor: pointer;
                padding: 5px;
            }
            
            .chat-window.fullscreen {
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                width: 100vw !important;
                height: 100vh !important;
                max-width: none !important;
                max-height: none !important;
                border-radius: 0 !important;
                z-index: 10000 !important;
            }
            
            .chat-window.fullscreen .chat-messages {
                height: calc(100vh - 140px) !important;
            }
            
            .send-btn {
                background: linear-gradient(45deg, #00d4ff, #5b86e5) !important;
                color: white !important;
                border: none !important;
                padding: 12px 16px !important;
                border-radius: 8px !important;
                cursor: pointer !important;
                font-size: 16px !important;
                min-width: 50px !important;
                transition: all 0.3s ease !important;
            }
            
            .send-btn:hover {
                transform: scale(1.05) !important;
                box-shadow: 0 3px 10px rgba(0, 212, 255, 0.4) !important;
            }
            
            .input-container {
                display: flex !important;
                gap: 10px !important;
                align-items: center !important;
            }
            
            .input-container input {
                flex: 1 !important;
            }
        }
        
        .emoji-header {
            padding: 10px !important;
            background: rgba(0, 212, 255, 0.1) !important;
            border-bottom: 1px solid #00d4ff !important;
            display: flex !important;
            justify-content: space-between !important;
            align-items: center !important;
        }
        
        .emoji-title {
            color: #00d4ff !important;
            font-weight: bold !important;
            font-size: 14px !important;
        }
        
        .emoji-close {
            background: none !important;
            border: none !important;
            color: #ff6b6b !important;
            font-size: 18px !important;
            cursor: pointer !important;
            padding: 0 !important;
            width: 20px !important;
            height: 20px !important;
        }
        
        .emoji-grid {
            padding: 10px !important;
            display: grid !important;
            grid-template-columns: repeat(8, 1fr) !important;
            gap: 5px !important;
            max-height: 250px !important;
            overflow-y: auto !important;
        }
        
        .emoji-item {
            background: none !important;
            border: none !important;
            font-size: 20px !important;
            padding: 8px !important;
            cursor: pointer !important;
            border-radius: 5px !important;
            transition: all 0.2s ease !important;
        }
        
        .emoji-item:hover {
            background: rgba(0, 212, 255, 0.2) !important;
            transform: scale(1.2) !important;
        }
        
        .emoji-footer {
            padding: 8px 10px !important;
            background: rgba(0, 212, 255, 0.05) !important;
            border-top: 1px solid rgba(0, 212, 255, 0.2) !important;
            font-size: 12px !important;
            color: #888 !important;
            text-align: center !important;
        }
        
        .btn-success {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(78, 205, 196, 0.4);
        }

        .modal-header {
            padding: 20px;
            border-bottom: 1px solid rgba(0, 212, 255, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h3 {
            margin: 0;
            color: #00d4ff;
        }

        .modal-body {
            padding: 20px;
        }

        .form-row {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }

        .form-group {
            flex: 1;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #00d4ff;
            font-weight: bold;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 14px;
        }

        .form-group textarea {
            height: 80px;
            resize: vertical;
        }

        .form-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .form-actions button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        
        /* MENU MOBILE HAMBURGER */
        .mobile-menu-btn {
            display: none;
            background: none;
            border: none;
            color: #00d4ff;
            font-size: 24px;
            cursor: pointer;
            padding: 10px;
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1001;
        }
        
        .mobile-nav {
            display: none;
        }
        
        .nav-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }
        
        .nav-overlay.active {
            display: block;
        }
        
        @media (max-width: 768px) {
            .mobile-menu-btn {
                display: block !important;
            }
            
            .mobile-nav {
                display: block !important;
            }
            
            .nav-links {
                position: fixed !important;
                top: 0 !important;
                right: -300px !important;
                width: 280px !important;
                height: 100vh !important;
                background: #1a1a2e !important;
                border-left: 2px solid #00d4ff !important;
                padding: 80px 20px 20px !important;
                margin: 0 !important;
                list-style: none !important;
                transition: right 0.3s ease !important;
                z-index: 1000 !important;
                overflow-y: auto !important;
            }
            
            .nav-links.mobile-open {
                right: 0 !important;
            }
            
            .nav-links li {
                margin-bottom: 15px !important;
            }
            
            .nav-links a {
                display: block !important;
                color: white !important;
                text-decoration: none !important;
                padding: 15px !important;
                border-radius: 8px !important;
                background: rgba(0, 212, 255, 0.1) !important;
                border: 1px solid rgba(0, 212, 255, 0.3) !important;
                transition: all 0.3s ease !important;
                font-size: 16px !important;
            }
            
            .nav-links a:hover {
                background: rgba(0, 212, 255, 0.2) !important;
                transform: translateX(-5px) !important;
            }
            
            .nav-overlay.active {
                display: block !important;
            }
        }
    </style>
    
    <!-- Boutons navigation mobile -->
    <div class="mobile-nav-buttons" style="position: fixed; bottom: 20px; left: 20px; right: 20px; z-index: 500; display: none;">
        <div style="display: flex; gap: 10px; justify-content: center;">
            <button onclick="window.location.href='vip-space.html'" style="background: rgba(0, 212, 255, 0.9); color: white; border: none; padding: 12px 16px; border-radius: 25px; cursor: pointer; backdrop-filter: blur(10px); font-size: 14px; font-weight: bold;">🏠 VIP</button>
            <button onclick="window.location.href='trading-dashboard.html'" style="background: rgba(0, 212, 255, 0.9); color: white; border: none; padding: 12px 16px; border-radius: 25px; cursor: pointer; backdrop-filter: blur(10px); font-size: 14px; font-weight: bold;">📈 Dashboard</button>
            <button onclick="window.history.back()" style="background: rgba(0, 212, 255, 0.9); color: white; border: none; padding: 12px 16px; border-radius: 25px; cursor: pointer; backdrop-filter: blur(10px); font-size: 14px; font-weight: bold;">🔙 Retour</button>
        </div>
    </div>
    
    <style>
        @media (max-width: 768px) {
            .mobile-nav-buttons {
                display: block !important;
            }
        }
    </style>
    

    
    <!-- Chat iMessage Structure -->
    <div id="chatWindow" class="chat-window">
        <div class="chat-header">
            <div class="chat-title">
                <span class="chat-icon">💬</span>
                <span class="chat-name">Chat VIP</span>
                <div class="online-indicator"></div>
            </div>
            <div class="chat-controls">
                <button id="chatSettingsBtn" class="chat-control-btn" title="Paramètres">
                    <span>⚙️</span>
                </button>
                <button id="chatFullscreenBtn" class="chat-control-btn chat-fullscreen-btn" title="Plein écran">
                    <span>🔍</span>
                </button>
                <button id="closeChatBtn" class="chat-control-btn" title="Fermer">
                    <span>✖️</span>
                </button>
            </div>
        </div>
        
        <div id="chatMessages" class="chat-messages">
            <div class="welcome-message">
                <div class="welcome-icon">👋</div>
                <div class="welcome-text">
                    <h4>Bienvenue dans le Chat VIP !</h4>
                    <p>Échangez avec les autres traders VIP en temps réel</p>
                </div>
            </div>
        </div>
        
        <div class="chat-input-container">
            <div class="input-container">
                <button id="emojiToggle" class="input-btn" title="Emojis">
                    <span>😀</span>
                </button>
                <button id="fileBtn" class="input-btn" title="Fichier">
                    <span>📎</span>
                </button>
                <button id="gifBtn" class="input-btn" title="GIF">
                    <span>🎬</span>
                </button>
                <input type="text" id="chatInput" placeholder="Tapez votre message..." maxlength="500">
                <button id="sendMessage" class="send-btn" title="Envoyer">
                    <span>🚀</span>
                </button>
            </div>
            
            <!-- Panel Emoji -->
            <div id="emojiPanel" class="emoji-picker-panel">
                <div class="emoji-header">
                    <div class="emoji-title">😀 Emojis</div>
                    <button id="emojiClose" class="emoji-close">✖️</button>
                </div>
                <div class="emoji-categories">
                    <button class="emoji-cat active" data-cat="smileys">😀</button>
                    <button class="emoji-cat" data-cat="people">👍</button>
                    <button class="emoji-cat" data-cat="nature">🌱</button>
                    <button class="emoji-cat" data-cat="food">🍎</button>
                    <button class="emoji-cat" data-cat="travel">🚗</button>
                    <button class="emoji-cat" data-cat="objects">💰</button>
                    <button class="emoji-cat" data-cat="symbols">❤️</button>
                </div>
                <div id="emojiGrid" class="emoji-grid"></div>
                <div class="emoji-footer">
                    <span id="emojiCount">0 emojis</span>
                </div>
            </div>
        </div>
        
        <input type="file" id="fileInput" accept="image/*,audio/*,.pdf,.doc,.docx" style="display: none;">
    </div>
    
    <!-- Bouton Chat Toggle -->
    <button id="chatToggle" class="chat-toggle">
        <span class="chat-toggle-icon">💬</span>
        <div id="chatBadge" class="chat-badge">0</div>
    </button>
    
    <!-- Modal Pseudo -->
    <div id="nicknameModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>👤 Choisir votre pseudo</h3>
            </div>
            <div class="modal-body">
                <p>Choisissez un pseudo pour le chat et le classement :</p>
                <input type="text" id="nicknameInput" placeholder="Votre pseudo..." maxlength="20">
                <div class="form-actions">
                    <button id="saveNickname" class="btn-primary">Sauvegarder</button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // EMOJIS - Version Ultra Simple qui Fonctionne
        window.toggleEmojiPanel = function() {
            console.log('🎯 Toggle emoji appelé');
            const panel = document.getElementById('emojiPanel');
            if (panel) {
                const isVisible = panel.style.display === 'block';
                if (isVisible) {
                    panel.style.display = 'none';
                    console.log('✅ Panel emoji: fermé');
                } else {
                    panel.style.display = 'block';
                    panel.style.position = 'absolute';
                    panel.style.bottom = '50px';
                    panel.style.left = '0';
                    panel.style.zIndex = '9999';
                    window.loadSimpleEmojis();
                    console.log('✅ Panel emoji: ouvert avec styles forcés');
                }
            } else {
                console.error('❌ Panel emoji introuvable');
            }
        };
        
        window.addEmojiToChat = function(emoji) {
            console.log('🎯 Ajout emoji au chat:', emoji);
            const input = document.getElementById('chatInput');
            if (input) {
                input.value += emoji;
                input.focus();
                console.log('✅ Emoji ajouté, input value:', input.value);
            } else {
                console.error('❌ Input chat introuvable');
            }
            const panel = document.getElementById('emojiPanel');
            if (panel) {
                panel.style.display = 'none';
                console.log('✅ Panel fermé après ajout');
            }
        };
        
        window.loadSimpleEmojis = function() {
            const grid = document.getElementById('emojiGrid');
            if (!grid) {
                console.error('❌ Grid emoji introuvable');
                return;
            }
            
            const emojis = ['😀', '😁', '😂', '🤣', '😃', '😄', '😅', '😆', '😉', '😊', '😋', '😎', '😍', '🥰', '😘', '😗', '😙', '😚', '🙂', '🤗', '🤔', '😐', '😑', '😶', '🙄', '😏', '😣', '😥', '😮', '🤐', '👍', '👎', '👌', '✌️', '🤞', '👊', '✊', '👏', '🙏', '💪', '❤️', '💛', '💚', '💙', '💜', '🖤', '🤍', '💰', '🚀', '🎉'];
            
            grid.innerHTML = '';
            emojis.forEach(emoji => {
                const btn = document.createElement('button');
                btn.className = 'emoji-item';
                btn.textContent = emoji;
                btn.style.cssText = 'background: none !important; border: none !important; font-size: 20px !important; padding: 8px !important; cursor: pointer !important; border-radius: 5px !important;';
                btn.onclick = function() { 
                    console.log('🎯 Emoji cliqué:', emoji);
                    window.addEmojiToChat(emoji); 
                };
                btn.onmouseover = function() {
                    btn.style.background = 'rgba(0, 212, 255, 0.2) !important';
                    btn.style.transform = 'scale(1.2)';
                };
                btn.onmouseout = function() {
                    btn.style.background = 'none !important';
                    btn.style.transform = 'scale(1)';
                };
                grid.appendChild(btn);
            });
            
            // Mettre à jour le compteur
            const emojiCount = document.getElementById('emojiCount');
            if (emojiCount) {
                emojiCount.textContent = `${emojis.length} emojis`;
            }
            
            console.log('✅ Emojis chargés avec styles:', emojis.length);
        };
        
        // Initialiser dès que possible
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(function() {
                console.log('🚀 Initialisation emojis...');
                window.loadSimpleEmojis();
            }, 1000);
        });
        
        // Menu mobile fix
        document.addEventListener('DOMContentLoaded', function() {
            const mobileMenuBtn = document.getElementById('mobileMenuBtn');
            const navLinks = document.getElementById('navLinks');
            const navOverlay = document.getElementById('navOverlay');
            
            if (mobileMenuBtn && navLinks) {
                mobileMenuBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    navLinks.classList.toggle('mobile-open');
                    if (navOverlay) navOverlay.classList.toggle('active');
                });
                
                if (navOverlay) {
                    navOverlay.addEventListener('click', function() {
                        navLinks.classList.remove('mobile-open');
                        navOverlay.classList.remove('active');
                    });
                }
            }
        });
        
        // Gestionnaire du classement VIP simplifié
        class VIPRanking {
            constructor() {
                this.currentUser = sessionStorage.getItem('firebaseUID') || 'trader_vip';
                this.userEmail = sessionStorage.getItem('userEmail') || 'Utilisateur';
                this.loadRanking();
                
                // Actualiser plus fréquemment (toutes les 10 secondes)
                setInterval(() => this.loadRanking(), 10000);
                
                // Écouter les changements Firebase en temps réel
                this.setupRealtimeListener();
            }
            
            async setupRealtimeListener() {
                try {
                    if (window.firebaseDB) {
                        const { ref, onValue } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-database.js');
                        
                        // Écouter les changements sur les données de trading
                        const tradingDataRef = ref(window.firebaseDB, 'trading_data');
                        onValue(tradingDataRef, () => {
                            console.log('Trading data changed, updating ranking...');
                            this.loadRanking();
                        });
                        
                        // Écouter les changements sur les utilisateurs
                        const usersRef = ref(window.firebaseDB, 'users');
                        onValue(usersRef, () => {
                            console.log('Users data changed, updating ranking...');
                            this.loadRanking();
                        });
                    }
                } catch (error) {
                    console.error('Error setting up realtime listener:', error);
                }
            }
            
            async loadRanking() {
                const rankingList = document.getElementById('rankingList');
                
                try {
                    rankingList.innerHTML = '<div class="ranking-loading">🔄 Chargement...</div>';
                    
                    if (window.firebaseDB) {
                        const { ref, get } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-database.js');
                        const usersRef = ref(window.firebaseDB, 'users');
                        const snapshot = await get(usersRef);
                        
                        if (snapshot.exists()) {
                            const users = snapshot.val();
                            const rankings = await this.calculateRankings(users);
                            this.displayRanking(rankings);
                        } else {
                            await this.showFallbackRanking();
                        }
                    } else {
                        this.showFallbackRanking();
                    }
                } catch (error) {
                    console.error('Erreur:', error);
                    this.showFallbackRanking();
                }
            }
            
            async calculateRankings(users) {
                const today = new Date().toISOString().split('T')[0];
                const rankings = [];
                
                for (const [userId, userData] of Object.entries(users)) {
                    if (userData.isVIP) {
                        const { dailyPnL, tradeCount } = await this.getUserStats(userId, today);
                        const displayName = await this.getDisplayNameForUser(userId, userData.email);
                        rankings.push({
                            name: displayName,
                            dailyPnL,
                            tradeCount,
                            userId
                        });
                    }
                }
                
                rankings.sort((a, b) => b.dailyPnL - a.dailyPnL);
                return rankings;
            }
            
            async getUserStats(userId, date) {
                try {
                    console.log(`🔍 Recherche stats pour userId: ${userId}, date: ${date}`);
                    
                    if (window.firebaseDB) {
                        const { ref, get, set } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-database.js');
                        
                        // Chercher dans plusieurs emplacements possibles
                        const possiblePaths = [
                            `dashboards/${userId}/trades`,
                            `trading_data/${userId}/trades`,
                            `users/${userId}/trades`,
                            `vip_users/${userId}/trades`
                        ];
                        
                        let tradesArray = [];
                        let foundPath = null;
                        
                        // Essayer chaque chemin
                        for (const path of possiblePaths) {
                            const tradesRef = ref(window.firebaseDB, path);
                            const snapshot = await get(tradesRef);
                            
                            if (snapshot.exists()) {
                                console.log(`✅ Données trouvées pour ${userId} dans: ${path}`);
                                const trades = snapshot.val();
                                foundPath = path;
                                
                                // Convertir en array si nécessaire
                                if (Array.isArray(trades)) {
                                    tradesArray = trades;
                                } else if (typeof trades === 'object') {
                                    tradesArray = Object.values(trades);
                                }
                                break;
                            }
                        }
                        
                        // Si pas trouvé et c'est l'utilisateur actuel, synchroniser depuis localStorage
                        if (tradesArray.length === 0 && userId === this.currentUser) {
                            console.log(`🔄 Tentative sync localStorage pour ${userId}`);
                            
                            // Essayer plusieurs clés localStorage
                            const localKeys = [
                                `dashboard_${userId}`,
                                'dashboardData',
                                `trading_${userId}`
                            ];
                            
                            for (const key of localKeys) {
                                const localData = localStorage.getItem(key);
                                if (localData) {
                                    try {
                                        const data = JSON.parse(localData);
                                        const trades = data.trades || data;
                                        
                                        if (Array.isArray(trades) && trades.length > 0) {
                                            console.log(`📤 Synchronisation ${trades.length} trades depuis localStorage (${key})`);
                                            
                                            // Synchroniser vers le chemin principal
                                            const mainTradesRef = ref(window.firebaseDB, `dashboards/${userId}/trades`);
                                            await set(mainTradesRef, trades);
                                            
                                            // Aussi vers trading_data pour compatibilité
                                            const altTradesRef = ref(window.firebaseDB, `trading_data/${userId}/trades`);
                                            await set(altTradesRef, trades);
                                            
                                            tradesArray = trades;
                                            foundPath = `dashboards/${userId}/trades`;
                                            console.log(`✅ Synchronisation terminée vers ${foundPath}`);
                                            break;
                                        }
                                    } catch (e) {
                                        console.error(`Erreur parsing localStorage ${key}:`, e);
                                    }
                                }
                            }
                        }
                        
                        console.log(`📊 Total trades trouvés: ${tradesArray.length} (chemin: ${foundPath})`);
                        
                        // Filtrer les trades d'aujourd'hui
                        const todayTrades = tradesArray.filter(trade => {
                            if (!trade || !trade.date) return false;
                            
                            const tradeDate = trade.date;
                            const isToday = tradeDate === date;
                            const isClosed = trade.status === 'closed' || trade.status === 'completed';
                            
                            console.log(`Trade ${trade.id || 'unknown'}: date=${tradeDate}, status=${trade.status}, isToday=${isToday}, isClosed=${isClosed}`);
                            return isToday && isClosed;
                        });
                        
                        const dailyPnL = todayTrades.reduce((total, trade) => {
                            const pnl = parseFloat(trade.pnl) || 0;
                            return total + pnl;
                        }, 0);
                        
                        console.log(`✅ ${todayTrades.length} trades d'aujourd'hui pour ${userId}, P&L: ${dailyPnL}`);
                        return { dailyPnL, tradeCount: todayTrades.length };
                    }
                    
                    return { dailyPnL: 0, tradeCount: 0 };
                } catch (error) {
                    console.error(`❌ Erreur getUserStats pour ${userId}:`, error);
                    return { dailyPnL: 0, tradeCount: 0 };
                }
            }
            
            async getDisplayName(email) {
                const fullUID = sessionStorage.getItem('firebaseUID') || this.currentUser;
                
                try {
                    if (window.firebaseDB) {
                        const { ref, get } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-database.js');
                        const nicknameRef = ref(window.firebaseDB, `users/${fullUID}/nickname`);
                        const snapshot = await get(nicknameRef);
                        
                        if (snapshot.exists()) {
                            return snapshot.val();
                        }
                    }
                } catch (error) {
                    console.error('Erreur récupération pseudo:', error);
                }
                
                if (!email) return 'Membre VIP';
                const name = email.split('@')[0];
                return name.charAt(0).toUpperCase() + name.slice(1);
            }
            
            async getDisplayNameForUser(userId, email) {
                try {
                    if (window.firebaseDB) {
                        const { ref, get } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-database.js');
                        const nicknameRef = ref(window.firebaseDB, `users/${userId}/nickname`);
                        const snapshot = await get(nicknameRef);
                        
                        if (snapshot.exists()) {
                            return snapshot.val();
                        }
                    }
                } catch (error) {
                    console.error('Erreur récupération pseudo:', error);
                }
                
                if (!email) return 'Membre VIP';
                const name = email.split('@')[0];
                return name.charAt(0).toUpperCase() + name.slice(1);
            }
            
            displayRanking(rankings) {
                const rankingList = document.getElementById('rankingList');
                
                console.log('Displaying ranking:', rankings);
                console.log('Current user ID:', this.currentUser);
                
                if (rankings.length === 0) {
                    if (rankingList.innerHTML !== '<div class="ranking-loading">Aucune donnée aujourd\'hui</div>') {
                        rankingList.style.opacity = '0.5';
                        setTimeout(() => {
                            rankingList.innerHTML = '<div class="ranking-loading">Aucune donnée aujourd\'hui</div>';
                            rankingList.style.opacity = '1';
                        }, 200);
                    }
                    return;
                }
                
                // Vérifier si l'utilisateur actuel est dans le classement
                const currentUserInRanking = rankings.find(trader => trader.userId === this.currentUser);
                console.log('Current user in ranking:', currentUserInRanking);
                
                let html = '';
                rankings.forEach((trader, index) => {
                    const isCurrentUser = trader.userId === this.currentUser;
                    const userClass = isCurrentUser ? ' current-user' : '';
                    
                    // Appliquer directement les couleurs
                    let pnlColor = '#ffc107'; // jaune pour neutre
                    if (trader.dailyPnL > 0) pnlColor = '#00ff00'; // vert pour positif
                    if (trader.dailyPnL < 0) pnlColor = '#ff0000'; // rouge pour négatif
                    
                    html += `
                        <div class="ranking-item${userClass}">
                            <span class="trader-name">${trader.name}${isCurrentUser ? ' (Vous)' : ''}</span>
                            <span class="trade-count">${trader.tradeCount} trades</span>
                            <span class="trader-pnl" style="color: ${pnlColor} !important;">$${trader.dailyPnL.toFixed(2)}</span>
                        </div>
                    `;
                });
                
                // Transition fluide
                if (rankingList.innerHTML !== html) {
                    rankingList.style.transition = 'opacity 0.3s ease';
                    rankingList.style.opacity = '0.7';
                    setTimeout(() => {
                        rankingList.innerHTML = html;
                        rankingList.style.opacity = '1';
                    }, 150);
                }
            }
            
            showFallbackRanking() {
                const demoRankings = [
                    { name: 'Trader Pro', dailyPnL: 250.50, tradeCount: 8 },
                    { name: 'Expert FX', dailyPnL: 180.25, tradeCount: 5 },
                    { name: 'Master Pips', dailyPnL: 120.75, tradeCount: 12 },
                    { name: this.getDisplayName(this.userEmail), dailyPnL: 0, tradeCount: 0 },
                    { name: 'Scalper King', dailyPnL: -45.30, tradeCount: 15 }
                ];
                
                demoRankings.sort((a, b) => b.dailyPnL - a.dailyPnL);
                this.displayRanking(demoRankings);
            }
        }
        
        // Enregistrer le service worker (fonctionne sur Netlify HTTPS)
        if ('serviceWorker' in navigator && location.protocol === 'https:') {
            window.addEventListener('load', async () => {
                try {
                    const registration = await navigator.serviceWorker.register('./sw.js');
                    await navigator.serviceWorker.ready;
                    console.log('✅ Service Worker enregistré sur Netlify:', registration.scope);
                } catch (error) {
                    console.error('❌ Erreur Service Worker:', error);
                }
            });
        }
        
        // Créer l'utilisateur VIP et synchroniser les trades
        async function ensureUserVIPAndSync() {
            try {
                const currentUser = sessionStorage.getItem('firebaseUID');
                const userEmail = sessionStorage.getItem('userEmail');
                if (!currentUser || !userEmail || !window.firebaseDB) return;
                
                const { ref, set, get, update } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-database.js');
                
                console.log(`🔧 Configuration utilisateur VIP: ${currentUser} (${userEmail})`);
                
                // 1. Créer/mettre à jour l'utilisateur VIP avec merge
                const userRef = ref(window.firebaseDB, `users/${currentUser}`);
                const userSnapshot = await get(userRef);
                
                const userData = {
                    email: userEmail,
                    isVIP: true,
                    plan: 'VIP',
                    status: 'active',
                    lastLogin: new Date().toISOString(),
                    lastActive: new Date().toISOString(),
                    autoCreated: true,
                    verified: true,
                    rankingEnabled: true
                };
                
                if (userSnapshot.exists()) {
                    // Mettre à jour sans écraser les données existantes
                    await update(userRef, userData);
                    console.log(`🔄 Utilisateur VIP mis à jour: ${userEmail}`);
                } else {
                    // Créer nouveau
                    userData.createdAt = new Date().toISOString();
                    await set(userRef, userData);
                    console.log(`✅ Nouvel utilisateur VIP créé: ${userEmail}`);
                }
                
                // 2. Synchroniser les trades vers plusieurs emplacements
                const localData = localStorage.getItem('dashboardData');
                if (localData) {
                    const data = JSON.parse(localData);
                    if (data.trades && data.trades.length > 0) {
                        console.log(`📊 Synchronisation ${data.trades.length} trades...`);
                        
                        // Synchroniser vers le chemin principal
                        const mainTradesRef = ref(window.firebaseDB, `dashboards/${currentUser}/trades`);
                        await set(mainTradesRef, data.trades);
                        
                        // Aussi vers trading_data pour compatibilité
                        const altTradesRef = ref(window.firebaseDB, `trading_data/${currentUser}/trades`);
                        await set(altTradesRef, data.trades);
                        
                        // Mettre à jour les stats utilisateur
                        const today = new Date().toISOString().split('T')[0];
                        const todayTrades = data.trades.filter(trade => 
                            trade && trade.date === today && (trade.status === 'closed' || trade.status === 'completed')
                        );
                        const dailyPnL = todayTrades.reduce((total, trade) => total + (parseFloat(trade.pnl) || 0), 0);
                        
                        const statsRef = ref(window.firebaseDB, `users/${currentUser}/stats`);
                        await set(statsRef, {
                            totalTrades: data.trades.length,
                            todayTrades: todayTrades.length,
                            dailyPnL: dailyPnL,
                            lastUpdated: new Date().toISOString()
                        });
                        
                        console.log(`✅ Synchronisation terminée: ${data.trades.length} trades, P&L aujourd'hui: $${dailyPnL}`);
                    }
                }
                
                // 3. Diagnostic complet
                await diagnosticUserRanking(currentUser);
                
            } catch (error) {
                console.error('❌ Erreur création utilisateur VIP:', error);
            }
        }
        
        // Fonction de diagnostic pour le classement
        async function diagnosticUserRanking(userId) {
            try {
                if (!window.firebaseDB) return;
                
                const { ref, get } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-database.js');
                
                console.log(`🔍 DIAGNOSTIC CLASSEMENT pour ${userId}:`);
                
                // Vérifier le statut utilisateur
                const userRef = ref(window.firebaseDB, `users/${userId}`);
                const userSnapshot = await get(userRef);
                
                if (userSnapshot.exists()) {
                    const userData = userSnapshot.val();
                    console.log(`👤 Utilisateur trouvé:`, {
                        email: userData.email,
                        isVIP: userData.isVIP,
                        plan: userData.plan,
                        status: userData.status
                    });
                } else {
                    console.log(`❌ Utilisateur non trouvé dans Firebase`);
                    return;
                }
                
                // Vérifier les trades dans tous les emplacements
                const paths = [
                    `dashboards/${userId}/trades`,
                    `trading_data/${userId}/trades`,
                    `users/${userId}/trades`
                ];
                
                for (const path of paths) {
                    const tradesRef = ref(window.firebaseDB, path);
                    const snapshot = await get(tradesRef);
                    
                    if (snapshot.exists()) {
                        const trades = snapshot.val();
                        const tradesArray = Array.isArray(trades) ? trades : Object.values(trades);
                        const today = new Date().toISOString().split('T')[0];
                        const todayTrades = tradesArray.filter(trade => 
                            trade && trade.date === today && (trade.status === 'closed' || trade.status === 'completed')
                        );
                        const dailyPnL = todayTrades.reduce((total, trade) => total + (parseFloat(trade.pnl) || 0), 0);
                        
                        console.log(`📊 ${path}: ${tradesArray.length} trades total, ${todayTrades.length} aujourd'hui, P&L: $${dailyPnL}`);
                    } else {
                        console.log(`❌ Pas de données dans ${path}`);
                    }
                }
                
                // Vérifier localStorage
                const localData = localStorage.getItem('dashboardData');
                if (localData) {
                    const data = JSON.parse(localData);
                    if (data.trades) {
                        console.log(`💾 localStorage: ${data.trades.length} trades`);
                    }
                }
                
            } catch (error) {
                console.error('❌ Erreur diagnostic:', error);
            }
        }
        
        // Initialiser le classement VIP quand la page est chargée
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(async () => {
                await ensureUserVIPAndSync();
                
                // Attendre un peu pour que la synchronisation soit terminée
                setTimeout(() => {
                    window.vipRanking = new VIPRanking();
                    new VIPChat();
                }, 2000);
                
                // Gestionnaires des boutons de diagnostic
                const refreshRankingBtn = document.getElementById('refreshRankingBtn');
                const diagnosticBtn = document.getElementById('diagnosticBtn');
                const fixRankingBtn = document.getElementById('fixRankingBtn');
                const testTradeBtn = document.getElementById('testTradeBtn');
                
                if (refreshRankingBtn) {
                    refreshRankingBtn.addEventListener('click', async () => {
                        refreshRankingBtn.innerHTML = '🔄 Chargement...';
                        refreshRankingBtn.disabled = true;
                        
                        try {
                            if (window.vipRanking) {
                                await window.vipRanking.loadRanking();
                            } else {
                                window.vipRanking = new VIPRanking();
                            }
                            refreshRankingBtn.innerHTML = '✅ Actualisé';
                            setTimeout(() => {
                                refreshRankingBtn.innerHTML = '🔄 Actualiser';
                                refreshRankingBtn.disabled = false;
                            }, 2000);
                        } catch (error) {
                            console.error('Erreur actualisation:', error);
                            refreshRankingBtn.innerHTML = '❌ Erreur';
                            setTimeout(() => {
                                refreshRankingBtn.innerHTML = '🔄 Actualiser';
                                refreshRankingBtn.disabled = false;
                            }, 2000);
                        }
                    });
                }
                
                if (diagnosticBtn) {
                    diagnosticBtn.addEventListener('click', async () => {
                        diagnosticBtn.innerHTML = '🔧 Analyse...';
                        diagnosticBtn.disabled = true;
                        
                        try {
                            if (window.diagnosticClassementComplet) {
                                const result = await window.diagnosticClassementComplet();
                                console.log('Résultat diagnostic:', result);
                            } else {
                                console.log('Fonction diagnostic non disponible');
                            }
                            diagnosticBtn.innerHTML = '✅ Voir console';
                            setTimeout(() => {
                                diagnosticBtn.innerHTML = '🔧 Diagnostic';
                                diagnosticBtn.disabled = false;
                            }, 3000);
                        } catch (error) {
                            console.error('Erreur diagnostic:', error);
                            diagnosticBtn.innerHTML = '❌ Erreur';
                            setTimeout(() => {
                                diagnosticBtn.innerHTML = '🔧 Diagnostic';
                                diagnosticBtn.disabled = false;
                            }, 2000);
                        }
                    });
                }
                
                if (fixRankingBtn) {
                    fixRankingBtn.addEventListener('click', async () => {
                        fixRankingBtn.innerHTML = '🛠️ Correction...';
                        fixRankingBtn.disabled = true;
                        
                        try {
                            // 1. Diagnostic complet
                            if (window.diagnosticClassementComplet) {
                                await window.diagnosticClassementComplet();
                            }
                            
                            // 2. Forcer la synchronisation
                            if (window.forcerSynchronisation) {
                                await window.forcerSynchronisation();
                            }
                            
                            // 3. Recharger le classement
                            if (window.vipRanking) {
                                await window.vipRanking.loadRanking();
                            }
                            
                            fixRankingBtn.innerHTML = '✅ Corrigé';
                            setTimeout(() => {
                                fixRankingBtn.innerHTML = '🛠️ Corriger';
                                fixRankingBtn.disabled = false;
                            }, 3000);
                        } catch (error) {
                            console.error('Erreur correction:', error);
                            fixRankingBtn.innerHTML = '❌ Erreur';
                            setTimeout(() => {
                                fixRankingBtn.innerHTML = '🛠️ Corriger';
                                fixRankingBtn.disabled = false;
                            }, 2000);
                        }
                    });
                }
                
                if (testTradeBtn) {
                    testTradeBtn.addEventListener('click', async () => {
                        testTradeBtn.innerHTML = '🧪 Création...';
                        testTradeBtn.disabled = true;
                        
                        try {
                            if (window.creerTradeTest) {
                                const testTrade = await window.creerTradeTest();
                                if (testTrade) {
                                    alert(`Trade de test créé: +$${testTrade.pnl} aujourd'hui`);
                                }
                            }
                            
                            testTradeBtn.innerHTML = '✅ Créé';
                            setTimeout(() => {
                                testTradeBtn.innerHTML = '🧪 Test';
                                testTradeBtn.disabled = false;
                            }, 2000);
                        } catch (error) {
                            console.error('Erreur création test:', error);
                            testTradeBtn.innerHTML = '❌ Erreur';
                            setTimeout(() => {
                                testTradeBtn.innerHTML = '🧪 Test';
                                testTradeBtn.disabled = false;
                            }, 2000);
                        }
                    });
                }
                
                // EMOJIS - Setup direct et simple
                const emojiToggle = document.getElementById('emojiToggle');
                const emojiPanel = document.getElementById('emojiPanel');
                
                if (emojiToggle && emojiPanel) {
                    console.log('🎯 Setup emojis direct...');
                    
                    // Event listener direct
                    emojiToggle.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('🎯 Bouton emoji cliqué !');
                        
                        const isVisible = emojiPanel.style.display === 'block';
                        if (isVisible) {
                            emojiPanel.style.display = 'none';
                            console.log('✅ Panel fermé');
                        } else {
                            emojiPanel.style.display = 'block';
                            emojiPanel.style.position = 'absolute';
                            emojiPanel.style.bottom = '50px';
                            emojiPanel.style.left = '0';
                            emojiPanel.style.zIndex = '9999';
                            emojiPanel.style.width = '300px';
                            emojiPanel.style.background = '#1a1a2e';
                            emojiPanel.style.border = '2px solid #00d4ff';
                            emojiPanel.style.borderRadius = '10px';
                            window.loadSimpleEmojis();
                            console.log('✅ Panel ouvert avec styles');
                        }
                    });
                    
                    // Charger les emojis immédiatement
                    window.loadSimpleEmojis();
                    console.log('✅ Emojis initialisés');
                } else {
                    console.error('❌ Elements emoji manquants');
                }
                
                // CHAT MOBILE - Bouton plein écran
                const chatFullscreenBtn = document.getElementById('chatFullscreenBtn');
                const chatWindow = document.getElementById('chatWindow');
                
                if (chatFullscreenBtn && chatWindow) {
                    chatFullscreenBtn.addEventListener('click', function() {
                        const isFullscreen = chatWindow.classList.contains('fullscreen');
                        if (isFullscreen) {
                            chatWindow.classList.remove('fullscreen');
                            chatFullscreenBtn.innerHTML = '🔍';
                            chatFullscreenBtn.title = 'Plein écran';
                        } else {
                            chatWindow.classList.add('fullscreen');
                            chatFullscreenBtn.innerHTML = '🔎';
                            chatFullscreenBtn.title = 'Quitter plein écran';
                        }
                    });
                }
            }, 1000);
        });
        
        // Fonctions emoji simplifiées déjà définies plus haut
        
        function loadBasicEmojis() {
            const emojiGrid = document.getElementById('emojiGrid');
            if (!emojiGrid) return;
            
            const basicEmojis = ['😀', '😁', '😂', '🤣', '😃', '😄', '😅', '😆', '😉', '😊', '😋', '😎', '😍', '🥰', '😘', '😗', '😙', '😚', '🙂', '🤗', '🤔', '😐', '😑', '😶', '🙄', '😏', '😣', '😥', '😮', '🤐', '👍', '👎', '👌', '❤️', '💚', '💙', '💜', '💰', '🚀', '🎉', '🎆', '🎈'];
            
            emojiGrid.innerHTML = '';
            basicEmojis.forEach(emoji => {
                const btn = document.createElement('button');
                btn.className = 'emoji-item';
                btn.textContent = emoji;
                btn.onclick = function() {
                    addEmojiToChat(emoji);
                };
                emojiGrid.appendChild(btn);
            });
        }
        
        // Setup direct des emojis
        function setupEmojisDirect() {
            console.log('Setup emojis direct...');
            loadBasicEmojis();
        }
        
        // Système de Chat VIP - Optimisé pour notifications
        class VIPChat {
            constructor() {
                this.currentUser = sessionStorage.getItem('firebaseUID') || 'trader_vip';
                this.soundEnabled = localStorage.getItem('chatSoundEnabled') !== 'false';
                this.pushEnabled = localStorage.getItem('chatPushEnabled') !== 'false';
                this.init();
            }
            
            async init() {
                this.nickname = await this.getNickname();
                await this.requestNotificationPermission();
                await this.setupFCM();
                this.setupChat();
                this.loadMessages();
                this.setupRealtimeListener();
                this.setupInstantNotificationListener();
                this.scheduleReset();
                
                // Heartbeat pour maintenir la connexion
                this.startHeartbeat();
            }
            
            async requestNotificationPermission() {
                if ('Notification' in window && 'serviceWorker' in navigator) {
                    try {
                        // Enregistrer le service worker
                        const registration = await navigator.serviceWorker.register('/sw.js');
                        console.log('Service Worker enregistré:', registration);
                        
                        if (Notification.permission === 'default') {
                            const permission = await Notification.requestPermission();
                            this.pushEnabled = permission === 'granted';
                            localStorage.setItem('chatPushEnabled', this.pushEnabled);
                        } else {
                            this.pushEnabled = Notification.permission === 'granted';
                        }
                    } catch (error) {
                        console.error('Erreur Service Worker:', error);
                        this.pushEnabled = false;
                    }
                }
            }
            
            async setupFCM() {
                try {
                    // 1. Enregistrer le service worker FCM
                    const registration = await navigator.serviceWorker.register('/firebase-messaging-sw.js');
                    console.log('✅ Service Worker FCM enregistré');
                    
                    // 2. Importer Firebase Messaging
                    const { getMessaging, getToken, onMessage } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-messaging.js');
                    const messaging = getMessaging();
                    
                    // 3. Obtenir le token FCM avec VAPID
                    // Essayer d'obtenir le token (peut échouer si clé VAPID incorrecte)
                    let token = null;
                    try {
                        token = await getToken(messaging, {
                            vapidKey: 'BBJatJBegeXBJjoYq_d7vIxpfIZn0qejbtQ31Fdgz7HzTk7NU-sfgjNsRsgDDxzIUpzr4chavlwjCBTgYHhheCY',
                            serviceWorkerRegistration: registration
                        });
                    } catch (vapidError) {
                        console.warn('⚠️ Erreur clé VAPID, notifications push désactivées:', vapidError);
                        // Continuer sans FCM, les notifications locales fonctionneront
                    }
                    
                    if (token) {
                        console.log('🔥 Token FCM obtenu:', token.substring(0, 20) + '...');
                        
                        // 4. Sauvegarder le token avec métadonnées
                        if (window.firebaseDB) {
                            const { ref, set } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-database.js');
                            const userRef = ref(window.firebaseDB, `users/${this.currentUser}`);
                            
                            await set(userRef, {
                                fcmToken: token,
                                tokenUpdated: new Date().toISOString(),
                                deviceInfo: {
                                    userAgent: navigator.userAgent,
                                    platform: navigator.platform,
                                    language: navigator.language
                                },
                                lastActive: new Date().toISOString(),
                                notificationsEnabled: true
                            }, { merge: true });
                        }
                        
                        // 5. Test de notification immédiat
                        setTimeout(() => {
                            if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                                navigator.serviceWorker.controller.postMessage({
                                    type: 'SHOW_NOTIFICATION',
                                    title: '🔔 Notifications activées',
                                    body: 'Vous recevrez maintenant les messages du chat VIP',
                                    icon: '/Misterpips.jpg'
                                });
                            }
                        }, 1000);
                    }
                    
                    // 6. Écouter les messages en premier plan
                    onMessage(messaging, (payload) => {
                        console.log('📱 Message FCM reçu en premier plan:', payload);
                        
                        // Afficher notification même si app ouverte
                        if (payload.notification) {
                            this.showInstantNotification(payload.notification.title, payload.notification.body);
                        }
                    });
                    
                    // 7. Écouter les notifications instantanées
                    this.setupInstantNotificationListener();
                    
                } catch (error) {
                    console.error('❌ Erreur FCM:', error);
                    // Fallback sans FCM
                    this.pushEnabled = false;
                }
            }
            
            async getNickname() {
                const fullUID = sessionStorage.getItem('firebaseUID') || this.currentUser;
                
                try {
                    if (window.firebaseDB) {
                        const { ref, get } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-database.js');
                        const nicknameRef = ref(window.firebaseDB, `users/${fullUID}/nickname`);
                        const snapshot = await get(nicknameRef);
                        
                        if (snapshot.exists()) {
                            const nickname = snapshot.val();
                            localStorage.setItem(`nickname_cache_${fullUID}`, nickname);
                            return nickname;
                        } else {
                            // Vérifier le cache avant de demander
                            const cachedNickname = localStorage.getItem(`nickname_cache_${fullUID}`);
                            if (cachedNickname) {
                                // Sauvegarder dans Firebase pour la prochaine fois
                                try {
                                    const { set } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-database.js');
                                    await set(nicknameRef, cachedNickname);
                                } catch (saveError) {
                                    console.error('Error saving cached nickname to Firebase:', saveError);
                                }
                                return cachedNickname;
                            }
                            
                            const nickname = await this.promptForNickname();
                            return nickname;
                        }
                    }
                } catch (error) {
                    console.error('Erreur récupération pseudo:', error);
                    const cachedNickname = localStorage.getItem(`nickname_cache_${fullUID}`);
                    if (cachedNickname) {
                        return cachedNickname;
                    }
                }
                
                return 'Membre VIP';
            }
            
            promptForNickname() {
                return new Promise((resolve) => {
                    const modal = document.getElementById('nicknameModal');
                    modal.style.display = 'block';
                    
                    document.getElementById('saveNickname').onclick = async () => {
                        const nickname = document.getElementById('nicknameInput').value.trim();
                        if (nickname) {
                            const fullUID = sessionStorage.getItem('firebaseUID') || this.currentUser;
                            
                            try {
                                if (window.firebaseDB) {
                                    const { ref, set } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-database.js');
                                    const nicknameRef = ref(window.firebaseDB, `users/${fullUID}/nickname`);
                                    await set(nicknameRef, nickname);
                                    // Mettre en cache
                                    localStorage.setItem(`nickname_cache_${fullUID}`, nickname);
                                }
                                
                                modal.style.display = 'none';
                                resolve(nickname);
                            } catch (error) {
                                console.error('Erreur sauvegarde pseudo:', error);
                                alert('Erreur lors de la sauvegarde du pseudo');
                            }
                        }
                    };
                });
            }
            
            showNicknameModal() {
                const modal = document.getElementById('nicknameModal');
                modal.style.display = 'block';
                
                document.getElementById('saveNickname').onclick = async () => {
                    const nickname = document.getElementById('nicknameInput').value.trim();
                    if (nickname) {
                        const fullUID = sessionStorage.getItem('firebaseUID') || this.currentUser;
                        
                        try {
                            if (window.firebaseDB) {
                                const { ref, set } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-database.js');
                                const nicknameRef = ref(window.firebaseDB, `users/${fullUID}/nickname`);
                                await set(nicknameRef, nickname);
                                // Mettre à jour le cache
                                localStorage.setItem(`nickname_cache_${fullUID}`, nickname);
                            }
                            
                            this.nickname = nickname;
                            modal.style.display = 'none';
                        } catch (error) {
                            console.error('Erreur sauvegarde pseudo:', error);
                            alert('Erreur lors de la sauvegarde du pseudo');
                        }
                    }
                };
            }
            
            setupChat() {
                const sendBtn = document.getElementById('sendMessage');
                const chatInput = document.getElementById('chatInput');
                const chatToggle = document.getElementById('chatToggle');
                const chatWindow = document.getElementById('chatWindow');
                const closeChatBtn = document.getElementById('closeChatBtn');
                
                if (!sendBtn || !chatInput || !chatToggle || !chatWindow || !closeChatBtn) {
                    console.error('Éléments chat manquants');
                    return;
                }
                
                // Améliorer le bouton d'envoi pour mobile
                sendBtn.style.cssText = 'background: linear-gradient(45deg, #00d4ff, #5b86e5) !important; color: white !important; border: none !important; padding: 12px 16px !important; border-radius: 8px !important; cursor: pointer !important; font-size: 16px !important; min-width: 50px !important; transition: all 0.3s ease !important;';
                
                this.messageCount = 0;
                this.lastMessageTime = parseInt(localStorage.getItem('lastChatCheck')) || 0;
                
                // Initialiser le badge
                const badge = document.getElementById('chatBadge');
                if (badge) {
                    this.unreadCount = 0;
                    badge.textContent = '0';
                    badge.style.display = 'none';
                    badge.classList.add('pulse-animation');
                }
                
                // Supprimer les anciens listeners
                sendBtn.replaceWith(sendBtn.cloneNode(true));
                const newSendBtn = document.getElementById('sendMessage');
                
                // Un seul listener pour l'envoi
                newSendBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('🚀 Bouton envoi cliqué');
                    this.sendMessage();
                });
                
                // Supprimer les anciens listeners sur l'input
                chatInput.replaceWith(chatInput.cloneNode(true));
                const newChatInput = document.getElementById('chatInput');
                
                newChatInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendMessage();
                    }
                });
                
                // Empêcher le zoom sur focus (mobile)
                chatInput.addEventListener('focus', () => {
                    if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
                        document.querySelector('meta[name=viewport]').setAttribute('content', 
                            'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no');
                    }
                });
                
                chatInput.addEventListener('blur', () => {
                    if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
                        document.querySelector('meta[name=viewport]').setAttribute('content', 
                            'width=device-width, initial-scale=1.0');
                    }
                });
                
                chatToggle.addEventListener('click', () => {
                    const isOpening = !chatWindow.classList.contains('show');
                    chatWindow.classList.toggle('show');
                    
                    if (isOpening) {
                        this.resetBadge();
                        this.markMessagesAsRead();
                        // Focus sur l'input après ouverture
                        setTimeout(() => {
                            chatInput.focus();
                            // Scroll vers le bas
                            const chatMessages = document.getElementById('chatMessages');
                            if (chatMessages) {
                                chatMessages.scrollTop = chatMessages.scrollHeight;
                            }
                        }, 300);
                    }
                });
                
                closeChatBtn.addEventListener('click', () => {
                    chatWindow.classList.remove('show');
                });
                
                const chatSettingsBtn = document.getElementById('chatSettingsBtn');
                if (chatSettingsBtn) {
                    chatSettingsBtn.addEventListener('click', () => {
                        this.showSettings();
                    });
                }
                
                // Fermer le chat en touchant en dehors (mobile)
                chatWindow.addEventListener('click', (e) => {
                    if (e.target === chatWindow) {
                        chatWindow.classList.remove('show');
                    }
                });
                
                // Initialiser les nouvelles fonctionnalités
                setTimeout(() => {
                    try {
                        console.log('Initialisation des fonctionnalités chat...');
                        window.vipChat = this;
                        console.log('Fonctionnalités chat initialisées');
                    } catch (error) {
                        console.error('Erreur initialisation fonctionnalités chat:', error);
                    }
                }, 500);
            }
            
            async sendMessage() {
                const input = document.getElementById('chatInput');
                const sendBtn = document.getElementById('sendMessage');
                const message = input.value.trim();
                
                if (!message || sendBtn.disabled) return;
                
                console.log('📤 Tentative envoi message:', message);
                
                // Désactiver le bouton immédiatement
                sendBtn.disabled = true;
                sendBtn.style.opacity = '0.6';
                input.value = ''; // Vider immédiatement
                
                const messageData = {
                    id: Date.now(),
                    userId: this.currentUser,
                    nickname: this.nickname,
                    message: message,
                    timestamp: Date.now(),
                    date: new Date().toISOString().split('T')[0]
                };
                
                try {
                    // Vérifier Firebase
                    if (!window.firebaseDB) {
                        throw new Error('Firebase non initialisé');
                    }
                    
                    console.log('🔥 Firebase DB disponible, envoi...');
                    
                    // Importer les fonctions Firebase
                    const { ref, push } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-database.js');
                    
                    // Envoyer à Firebase
                    const messagesRef = ref(window.firebaseDB, 'vip_chat');
                    const result = await push(messagesRef, messageData);
                    
                    console.log('✅ Message envoyé avec succès:', result.key);
                    
                    // PAS de notification pour ses propres messages
                    console.log('✅ Message envoyé avec succès - pas de notification pour l\'expéditeur');
                    
                } catch (error) {
                    console.error('❌ Erreur envoi Firebase:', error);
                    
                    // Restaurer le message dans l'input
                    input.value = message;
                    
                    // Afficher l'erreur spécifique
                    let errorMsg = 'Erreur de connexion Firebase';
                    if (error.code === 'permission-denied') {
                        errorMsg = 'Permissions insuffisantes';
                    } else if (error.code === 'network-request-failed') {
                        errorMsg = 'Problème de connexion internet';
                    } else if (error.message.includes('Firebase')) {
                        errorMsg = 'Service Firebase indisponible';
                    }
                    
                    alert(`❌ ${errorMsg}. Vérifiez votre connexion et réessayez.`);
                } finally {
                    // Réactiver le bouton
                    sendBtn.disabled = false;
                    sendBtn.style.opacity = '1';
                }
            }
            
            displayLocalMessage(messageData) {
                const chatMessages = document.getElementById('chatMessages');
                if (!chatMessages) {
                    console.error('❌ Element chatMessages introuvable');
                    return;
                }
                
                const time = new Date(messageData.timestamp).toLocaleTimeString('fr-FR', {
                    hour: '2-digit',
                    minute: '2-digit'
                });
                
                const messageDiv = document.createElement('div');
                messageDiv.className = 'chat-message message-own';
                messageDiv.style.cssText = 'margin-bottom: 10px; padding: 10px; background: rgba(0, 212, 255, 0.1); border-radius: 8px; border-left: 3px solid #00d4ff;';
                messageDiv.innerHTML = `
                    <div class="message-header" style="display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 12px; opacity: 0.8;">
                        <span class="message-nickname" style="color: #00d4ff; font-weight: bold;">${messageData.nickname}</span>
                        <span class="message-time" style="color: #888;">${time}</span>
                    </div>
                    <div class="message-content" style="color: white; line-height: 1.4;">${messageData.message}</div>
                `;
                
                chatMessages.appendChild(messageDiv);
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
                console.log('✅ Message affiché localement');
            }
            
            async loadMessages() {
                try {
                    if (window.firebaseDB) {
                        const { ref, query, orderByKey, limitToLast, get } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-database.js');
                        const messagesRef = ref(window.firebaseDB, 'vip_chat');
                        const recentMessagesQuery = query(messagesRef, orderByKey(), limitToLast(10));
                        const snapshot = await get(recentMessagesQuery);
                        
                        if (snapshot.exists()) {
                            const messages = Object.values(snapshot.val());
                            this.displayMessages(messages);
                        }
                    }
                } catch (error) {
                    console.error('Erreur chargement messages:', error);
                }
            }
            
            async setupRealtimeListener() {
                try {
                    if (window.firebaseDB) {
                        const { ref, query, orderByKey, limitToLast, onValue } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-database.js');
                        const messagesRef = ref(window.firebaseDB, 'vip_chat');
                        const recentMessagesQuery = query(messagesRef, orderByKey(), limitToLast(10));
                        
                        onValue(recentMessagesQuery, (snapshot) => {
                            if (snapshot.exists()) {
                                const messages = Object.values(snapshot.val());
                                this.displayMessages(messages);
                                
                                // Notification uniquement pour nouveaux messages
                                const latestMessage = messages[messages.length - 1];
                                if (latestMessage && latestMessage.userId !== this.currentUser) {
                                    const timeDiff = Date.now() - latestMessage.timestamp;
                                    if (timeDiff < 2000) { // Message de moins de 2 secondes
                                        this.showInstantMobileNotification(latestMessage);
                                    }
                                }
                            }
                        });
                    }
                } catch (error) {
                    console.error('Erreur listener temps réel:', error);
                }
            }
            
            displayMessages(messages) {
                const chatMessages = document.getElementById('chatMessages');
                messages.sort((a, b) => a.timestamp - b.timestamp);
                
                // Compter les nouveaux messages
                const newMessages = messages.filter(msg => 
                    msg.timestamp > this.lastMessageTime && msg.userId !== this.currentUser
                );
                
                const chatWindow = document.getElementById('chatWindow');
                const isChatOpen = chatWindow && chatWindow.classList.contains('show');
                
                if (newMessages.length > 0) {
                    if (!isChatOpen) {
                        this.updateBadge(newMessages.length);
                        this.playNotificationSound();
                    } else {
                        this.markMessagesAsRead();
                    }
                }
                
                let html = '';
                messages.forEach(msg => {
                    const time = new Date(msg.timestamp).toLocaleTimeString('fr-FR', {
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                    
                    const isCurrentUser = msg.userId === this.currentUser;
                    const messageClass = isCurrentUser ? 'message-own' : 'message-other';
                    
                    let content = '';
                    if (msg.file) {
                        if (msg.file.type.startsWith('image/')) {
                            content = `<img src="${msg.file.data}" alt="${msg.file.name}" class="message-image">`;
                        } else if (msg.file.type.startsWith('audio/')) {
                            content = `<audio controls class="message-audio"><source src="${msg.file.data}" type="${msg.file.type}"></audio>`;
                        } else {
                            content = `<div class="message-file">📁 ${msg.file.name}</div>`;
                        }
                    } else if (msg.message.includes('[GIF:')) {
                        const gifUrl = msg.message.match(/\[GIF:(.+?)\]/)?.[1];
                        if (gifUrl) {
                            content = `<img src="${gifUrl}" alt="GIF" class="message-gif">`;
                        } else {
                            content = msg.message;
                        }
                    } else {
                        content = msg.message;
                    }
                    
                    html += `
                        <div class="chat-message ${messageClass}">
                            <div class="message-header">
                                <span class="message-nickname">${msg.nickname}</span>
                                <span class="message-time">${time}</span>
                            </div>
                            <div class="message-content">${content}</div>
                        </div>
                    `;
                });
                
                chatMessages.innerHTML = html;
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
                // Mettre à jour le timestamp de dernière vérification
                if (messages.length > 0) {
                    this.lastMessageTime = Math.max(...messages.map(m => m.timestamp));
                    localStorage.setItem('lastChatCheck', this.lastMessageTime);
                }
            }
            
            scheduleReset() {
                const now = new Date();
                const tomorrow = new Date(now);
                tomorrow.setDate(tomorrow.getDate() + 1);
                tomorrow.setHours(0, 0, 0, 0);
                
                const timeUntilMidnight = tomorrow.getTime() - now.getTime();
                
                setTimeout(() => {
                    this.resetChat();
                    setInterval(() => this.resetChat(), 24 * 60 * 60 * 1000);
                }, timeUntilMidnight);
            }
            
            setupInstantNotificationListener() {
                if (!window.firebaseDB) return;
                
                try {
                    import('https://www.gstatic.com/firebasejs/10.7.0/firebase-database.js').then(({ ref, onValue }) => {
                        const instantRef = ref(window.firebaseDB, 'instant_notifications');
                        
                        onValue(instantRef, (snapshot) => {
                            if (snapshot.exists()) {
                                const notifications = Object.entries(snapshot.val());
                                
                                notifications.forEach(([key, notification]) => {
                                    // Vérifier si c'est une nouvelle notification (moins de 30 secondes)
                                    const isRecent = (Date.now() - notification.timestamp) < 30000;
                                    const isNotFromMe = notification.senderId !== this.currentUser;
                                    
                                    if (isRecent && isNotFromMe && !notification.processed) {
                                        console.log('📱 Notification instantanée reçue:', notification);
                                        this.showInstantNotification(notification.title, notification.body);
                                    }
                                });
                            }
                        });
                    });
                } catch (error) {
                    console.error('Erreur listener notifications instantanées:', error);
                }
            }
            
            showInstantNotification(title, body) {
                // UNE SEULE notification - éviter les doublons
                const notificationsDisabled = localStorage.getItem('chatNotificationsDisabled') === 'true';
                if (notificationsDisabled || !this.pushEnabled) return;
                
                // Utiliser un tag unique pour éviter les doublons
                const uniqueTag = 'chat-' + this.currentUser;
                
                if ('Notification' in window && Notification.permission === 'granted') {
                    try {
                        const notification = new Notification(title, {
                            body: body,
                            icon: '/Misterpips.jpg',
                            tag: uniqueTag, // Tag unique pour remplacer les anciennes
                            requireInteraction: false,
                            vibrate: [100, 50, 100],
                            silent: false
                        });
                        
                        setTimeout(() => {
                            try { notification.close(); } catch(e) {}
                        }, 4000);
                    } catch (error) {
                        console.error('Erreur notification:', error);
                    }
                }
            }
            
            startHeartbeat() {
                // Maintenir la connexion active
                setInterval(async () => {
                    if (window.firebaseDB) {
                        try {
                            const { ref, set } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-database.js');
                            const heartbeatRef = ref(window.firebaseDB, `users/${this.currentUser}/lastSeen`);
                            await set(heartbeatRef, Date.now());
                        } catch (error) {
                            console.error('Erreur heartbeat:', error);
                        }
                    }
                }, 60000); // Toutes les minutes
            }
            
            async resetChat() {
                try {
                    if (window.firebaseDB) {
                        const { ref, remove } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-database.js');
                        const messagesRef = ref(window.firebaseDB, 'vip_chat');
                        await remove(messagesRef);
                    }
                    
                    document.getElementById('chatMessages').innerHTML = '<div class="chat-reset">💬 Nouveau jour, nouveau chat !</div>';
                } catch (error) {
                    console.error('Erreur reset chat:', error);
                }
            }
        }
        
        // Système d'émojis complet et optimisé
        const emojiData = {
            smileys: ['😀', '😁', '😂', '🤣', '😃', '😄', '😅', '😆', '😉', '😊', '😋', '😎', '😍', '🥰', '😘', '😗', '😙', '😚', '🙂', '🤗', '🤔', '🤨', '😐', '😑', '😶', '🙄', '😏', '😣', '😥', '😮', '🤐', '😯', '😪', '😫', '🥱', '😴', '😌', '😛', '😜', '😝', '🤤'],
            people: ['👍', '👎', '👌', '✌️', '🤞', '🤟', '🤘', '👊', '✊', '🤛', '🤜', '👏', '🙌', '👐', '🤲', '🙏', '✍️', '💪', '🦾', '🦿', '🦵', '🦶', '👂', '🦻', '👃', '🧠', '🫀', '🫁', '🦷', '🦴', '👀', '👁️', '👅', '👄', '💋', '🩸'],
            nature: ['🌱', '🌿', '🍀', '🌳', '🌲', '🌴', '🌵', '🌾', '🌷', '🌸', '🌹', '🥀', '🌺', '🌻', '🌼', '🌽', '🍄', '🌰', '🌊', '💧', '🔥', '⭐', '🌟', '💫', '⚡', '☀️', '🌤️', '⛅', '🌦️', '🌧️', '⛈️', '🌩️', '🌨️', '❄️', '☃️', '⛄', '🌬️', '💨', '🌪️', '🌫️', '🌈'],
            food: ['🍎', '🍊', '🍋', '🍌', '🍉', '🍇', '🍓', '🫐', '🍈', '🍒', '🍑', '🥭', '🍍', '🥥', '🥝', '🍅', '🍆', '🥑', '🥦', '🥬', '🥒', '🌶️', '🫑', '🌽', '🥕', '🫒', '🧄', '🧅', '🥔', '🍠', '🥐', '🥖', '🍞', '🥨', '🥯', '🧀', '🥚', '🍳', '🧈', '🥞', '🧇', '🥓', '🥩', '🍗', '🍖', '🌭', '🍔', '🍟', '🍕'],
            travel: ['🚗', '🚕', '🚙', '🚌', '🚎', '🏎️', '🚓', '🚑', '🚒', '🚐', '🛻', '🚚', '🚛', '🚜', '🏍️', '🛵', '🚲', '🛴', '🛹', '🛼', '🚁', '🛸', '✈️', '🛩️', '🛫', '🛬', '🪂', '💺', '🚀', '🛰️', '🚢', '⛵', '🚤', '🛥️', '🛳️', '⛴️', '🚂', '🚃', '🚄', '🚅', '🚆', '🚇', '🚈', '🚉', '🚊', '🚝', '🚞', '🚋', '🚌'],
            objects: ['💰', '💸', '💵', '💴', '💶', '💷', '🪙', '💳', '💎', '⚖️', '🪜', '🔧', '🔨', '⚒️', '🛠️', '⛏️', '🔩', '⚙️', '🪚', '🔫', '🏹', '🛡️', '🪃', '🔪', '🗡️', '⚔️', '💣', '🪓', '🔮', '📿', '🧿', '🪬', '⚗️', '🔭', '🔬', '🕳️', '🩹', '🩺', '💊', '💉', '🧬', '🦠', '🧫', '🧪', '🌡️', '🧹', '🪠', '🧽', '🧴', '🧷', '🧲', '🪝'],
            symbols: ['❤️', '🧡', '💛', '💚', '💙', '💜', '🖤', '🤍', '🤎', '💔', '❤️‍🔥', '❤️‍🩹', '❣️', '💕', '💞', '💓', '💗', '💖', '💘', '💝', '💟', '☮️', '✝️', '☪️', '🕉️', '☸️', '✡️', '🔯', '🕎', '☯️', '☦️', '🛐', '⛎', '♈', '♉', '♊', '♋', '♌', '♍', '♎', '♏', '♐', '♑', '♒', '♓', '🆔', '⚡', '💥', '💫', '💦', '💨', '🕳️', '💬', '👁️‍🗨️', '🗨️', '🗯️', '💭', '💤']
        };
        
        function initEmojiPicker() {
            const emojiToggle = document.getElementById('emojiToggle');
            const emojiPanel = document.getElementById('emojiPanel');
            const emojiGrid = document.getElementById('emojiGrid');
            
            if (!emojiToggle || !emojiPanel || !emojiGrid) {
                console.warn('Éléments emoji picker manquants');
                return;
            }
            
            let isOpen = false;
            
            // Charger les emojis de base
            loadEmojis('smileys');
            
            // Toggle du panel
            emojiToggle.onclick = function(e) {
                e.preventDefault();
                isOpen = !isOpen;
                emojiPanel.style.display = isOpen ? 'block' : 'none';
            };
            
            // Catégories
            document.querySelectorAll('.emoji-cat').forEach(cat => {
                cat.onclick = function(e) {
                    e.preventDefault();
                    document.querySelectorAll('.emoji-cat').forEach(c => c.classList.remove('active'));
                    cat.classList.add('active');
                    loadEmojis(cat.dataset.cat);
                };
            });
            
            // Fermer en cliquant ailleurs
            document.onclick = function(e) {
                if (!emojiPanel.contains(e.target) && !emojiToggle.contains(e.target)) {
                    isOpen = false;
                    emojiPanel.style.display = 'none';
                }
            };
            
            function loadEmojis(category) {
                if (!emojiData[category]) return;
                
                emojiGrid.innerHTML = '';
                const emojis = emojiData[category];
                
                emojis.forEach(emoji => {
                    const btn = document.createElement('button');
                    btn.className = 'emoji-item';
                    btn.textContent = emoji;
                    btn.type = 'button';
                    
                    btn.onclick = function(e) {
                        e.preventDefault();
                        insertEmoji(emoji);
                    };
                    
                    emojiGrid.appendChild(btn);
                });
                
                // Mettre à jour le compteur
                const emojiCount = document.getElementById('emojiCount');
                if (emojiCount) {
                    emojiCount.textContent = `${emojis.length} emojis`;
                }
            }
        }
        
        function insertEmoji(emoji) {
            const input = document.getElementById('chatInput');
            if (input) {
                input.value += emoji;
                input.focus();
            }
            
            // Fermer le panel
            const emojiPanel = document.getElementById('emojiPanel');
            if (emojiPanel) {
                emojiPanel.style.display = 'none';
            }
        }
        
        function initFileUpload() {
            const fileBtn = document.getElementById('fileBtn');
            const fileInput = document.getElementById('fileInput');
            
            fileBtn.onclick = () => fileInput.click();
            
            fileInput.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    if (file.size > 5 * 1024 * 1024) {
                        alert('Fichier trop volumineux (max 5MB)');
                        return;
                    }
                    
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const fileData = {
                            name: file.name,
                            type: file.type,
                            data: e.target.result,
                            size: file.size
                        };
                        sendFileMessage(fileData);
                    };
                    reader.readAsDataURL(file);
                }
            };
        }
        
        async function sendFileMessage(fileData) {
            const messageData = {
                id: Date.now(),
                userId: window.vipChat.currentUser,
                nickname: window.vipChat.nickname,
                message: '',
                file: fileData,
                timestamp: Date.now(),
                date: new Date().toISOString().split('T')[0]
            };
            
            try {
                if (window.firebaseDB) {
                    const { ref, push } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-database.js');
                    const messagesRef = ref(window.firebaseDB, 'vip_chat');
                    await push(messagesRef, messageData);
                }
            } catch (error) {
                console.error('Erreur envoi fichier:', error);
            }
        }
        
        function initGifSearch() {
            const gifBtn = document.getElementById('gifBtn');
            gifBtn.onclick = () => {
                const gifUrl = prompt('URL du GIF (Giphy, Tenor, etc.):');
                if (gifUrl) {
                    insertEmoji(`[GIF:${gifUrl}]`);
                }
            };
        }
        
        // Fonction d'améliorations supplémentaires du chat
        function initChatEnhancements() {
            const chatInput = document.getElementById('chatInput');
            const sendBtn = document.getElementById('sendMessage');
            const emojiClose = document.getElementById('emojiClose');
            
            // Bouton de fermeture du picker d'emojis
            if (emojiClose) {
                emojiClose.onclick = function(e) {
                    e.preventDefault();
                    document.getElementById('emojiPanel').style.display = 'none';
                };
            }
            
            // Animation du bouton d'envoi
            if (sendBtn && chatInput) {
                chatInput.oninput = function() {
                    if (chatInput.value.trim()) {
                        sendBtn.classList.add('active');
                    } else {
                        sendBtn.classList.remove('active');
                    }
                };
            }
        }
        
        function filterEmojis(query) {
            const emojiGrid = document.getElementById('emojiGrid');
            const emojiCount = document.getElementById('emojiCount');
            
            if (!query) {
                // Recharger la catégorie active
                const activeCategory = document.querySelector('.emoji-cat.active');
                if (activeCategory) {
                    loadEmojis(activeCategory.dataset.cat);
                }
                return;
            }
            
            // Recherche dans tous les emojis
            const allEmojis = [];
            Object.values(emojiData).forEach(categoryEmojis => {
                allEmojis.push(...categoryEmojis);
            });
            
            // Filtrer (recherche simple par maintenant)
            const filteredEmojis = allEmojis.filter(emoji => {
                // Ici on pourrait ajouter une logique de recherche plus sophistiquée
                return true; // Pour l'instant, on affiche tous les emojis
            });
            
            // Afficher les résultats
            emojiGrid.innerHTML = '';
            filteredEmojis.slice(0, 50).forEach(emoji => {
                const btn = document.createElement('button');
                btn.className = 'emoji-item';
                btn.textContent = emoji;
                btn.type = 'button';
                
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    insertEmoji(emoji);
                });
                
                emojiGrid.appendChild(btn);
            });
            
            if (emojiCount) {
                emojiCount.textContent = `${Math.min(filteredEmojis.length, 50)} emojis`;
            }
        }
        
        function showTypingIndicator() {
            // Placeholder pour indicateur de frappe
        }
        
        function hideTypingIndicator() {
            // Placeholder pour cacher l'indicateur
        }
        
        // Fonctions emoji simplifiées déjà définies plus haut
        
        // Méthodes pour le badge et les notifications
        VIPChat.prototype.updateBadge = function(count) {
            const badge = document.getElementById('chatBadge');
            this.unreadCount = (this.unreadCount || 0) + count;
            
            if (this.unreadCount > 0) {
                badge.textContent = this.unreadCount > 99 ? '99+' : this.unreadCount;
                badge.style.display = 'flex';
                badge.classList.add('bounce-animation');
                
                // Animation de pulsation
                setTimeout(() => {
                    badge.classList.remove('bounce-animation');
                }, 600);
            }
        };
        
        VIPChat.prototype.resetBadge = function() {
            const badge = document.getElementById('chatBadge');
            this.unreadCount = 0;
            badge.textContent = '0';
            badge.style.display = 'none';
            badge.classList.remove('bounce-animation', 'pulse-animation');
        };
        
        VIPChat.prototype.markMessagesAsRead = function() {
            this.lastMessageTime = Date.now();
            localStorage.setItem('lastChatCheck', this.lastMessageTime);
        };
        
        VIPChat.prototype.playNotificationSound = function() {
            const notificationsDisabled = localStorage.getItem('chatNotificationsDisabled') === 'true';
            if (!this.soundEnabled || notificationsDisabled) return;
            
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                oscillator.frequency.setValueAtTime(600, audioContext.currentTime + 0.1);
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.2);
            } catch (error) {
                console.log('Son de notification non disponible');
            }
        };
        
        VIPChat.prototype.showInstantMobileNotification = function(message) {
            const notificationsDisabled = localStorage.getItem('chatNotificationsDisabled') === 'true';
            const chatWindowOpen = document.getElementById('chatWindow').classList.contains('show');
            
            // Ne pas notifier si chat ouvert ou notifications désactivées
            if (chatWindowOpen || notificationsDisabled || !this.pushEnabled) return;
            
            const notificationBody = `${message.nickname}: ${message.message.substring(0, 30)}${message.message.length > 30 ? '...' : ''}`;
            
            // UNE SEULE notification avec tag unique
            if ('Notification' in window && Notification.permission === 'granted') {
                const notification = new Notification('💬 Message VIP', {
                    body: notificationBody,
                    icon: '/Misterpips.jpg',
                    tag: 'vip-chat-' + this.currentUser, // Tag unique pour éviter doublons
                    requireInteraction: false,
                    vibrate: [100, 50, 100],
                    silent: false
                });
                
                notification.onclick = () => {
                    window.focus();
                    document.getElementById('chatWindow').classList.add('show');
                    this.resetBadge();
                    notification.close();
                };
                
                setTimeout(() => {
                    try { notification.close(); } catch(e) {}
                }, 4000);
            }
        };
        
        VIPChat.prototype.sendInstantPushNotification = async function(message) {
            try {
                if (!window.firebaseDB) return;
                
                const { ref, get, push, set } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-database.js');
                
                // Notification INSTANTANÉE - Priorité haute
                const instantNotification = {
                    type: 'INSTANT_CHAT',
                    title: '💬 Nouveau message VIP',
                    body: `${message.nickname}: ${message.message.substring(0, 50)}${message.message.length > 50 ? '...' : ''}`,
                    sender: message.nickname,
                    senderId: message.userId,
                    timestamp: Date.now(),
                    priority: 'high',
                    ttl: 3600, // 1 heure
                    processed: false
                };
                
                // 1. Notification immédiate pour tous les utilisateurs VIP connectés
                const instantRef = ref(window.firebaseDB, 'instant_notifications');
                await push(instantRef, instantNotification);
                
                // 2. Obtenir les tokens FCM pour push notifications
                const usersRef = ref(window.firebaseDB, 'users');
                const snapshot = await get(usersRef);
                
                if (snapshot.exists()) {
                    const users = snapshot.val();
                    const activeTokens = [];
                    
                    Object.entries(users).forEach(([uid, userData]) => {
                        if (userData.isVIP && userData.fcmToken && uid !== this.currentUser) {
                            // Vérifier si l'utilisateur est actif (dernière activité < 24h)
                            const lastActive = userData.lastActive || userData.lastLogin;
                            const isRecentlyActive = lastActive && (Date.now() - new Date(lastActive).getTime()) < 24 * 60 * 60 * 1000;
                            
                            if (isRecentlyActive || !lastActive) {
                                activeTokens.push({
                                    token: userData.fcmToken,
                                    uid: uid,
                                    email: userData.email
                                });
                            }
                        }
                    });
                    
                    if (activeTokens.length > 0) {
                        // 3. Push notification avec retry automatique
                        const pushData = {
                            ...instantNotification,
                            tokens: activeTokens.map(t => t.token),
                            recipients: activeTokens,
                            retryCount: 0,
                            maxRetries: 3
                        };
                        
                        const pushRef = ref(window.firebaseDB, 'push_notifications');
                        await push(pushRef, pushData);
                        
                        console.log(`📱 Push notification envoyée à ${activeTokens.length} utilisateurs`);
                    }
                }
                
                // 4. Mettre à jour l'activité de l'expéditeur
                const senderRef = ref(window.firebaseDB, `users/${this.currentUser}/lastActive`);
                await set(senderRef, new Date().toISOString());
                
            } catch (error) {
                console.error('❌ Erreur push notification:', error);
            }
        };
        
        VIPChat.prototype.showSettings = function() {
            const notificationsDisabled = localStorage.getItem('chatNotificationsDisabled') === 'true';
            const settingsHtml = `
                <div class="chat-settings">
                    <h4>⚙️ Paramètres du Chat</h4>
                    <div class="setting-item">
                        <label class="setting-label">
                            <div class="checkbox-container">
                                <input type="checkbox" id="notificationsToggle" ${!notificationsDisabled ? 'checked' : ''}>
                                <span class="checkmark"></span>
                            </div>
                            <span class="setting-text">Activer toutes les notifications</span>
                        </label>
                        <small class="setting-help">
                            Désactive complètement sons et notifications push
                        </small>
                    </div>
                    <div class="setting-item" id="soundSetting" style="${notificationsDisabled ? 'opacity: 0.5; pointer-events: none;' : ''}">
                        <label class="setting-label">
                            <div class="checkbox-container">
                                <input type="checkbox" id="soundToggle" ${this.soundEnabled && !notificationsDisabled ? 'checked' : ''}>
                                <span class="checkmark"></span>
                            </div>
                            <span class="setting-text">Sons de notification</span>
                        </label>
                    </div>
                    <div class="setting-item" id="pushSetting" style="${notificationsDisabled ? 'opacity: 0.5; pointer-events: none;' : ''}">
                        <label class="setting-label">
                            <div class="checkbox-container">
                                <input type="checkbox" id="pushToggle" ${this.pushEnabled && !notificationsDisabled ? 'checked' : ''}>
                                <span class="checkmark"></span>
                            </div>
                            <span class="setting-text">Notifications push (mobile)</span>
                        </label>
                        <small class="setting-help">
                            ${this.getNotificationHelp()}
                        </small>
                    </div>
                    <div class="setting-item">
                        <button id="changeNicknameBtn" class="setting-btn">👤 Changer le pseudo</button>
                    </div>
                    <div class="setting-actions">
                        <button id="saveSettingsBtn" class="setting-btn primary">💬 Retour au chat</button>
                    </div>
                </div>
            `;
            
            const chatMessages = document.getElementById('chatMessages');
            chatMessages.innerHTML = settingsHtml;
            
            document.getElementById('notificationsToggle').onchange = (e) => {
                const enabled = e.target.checked;
                localStorage.setItem('chatNotificationsDisabled', !enabled);
                
                const soundSetting = document.getElementById('soundSetting');
                const pushSetting = document.getElementById('pushSetting');
                const soundToggle = document.getElementById('soundToggle');
                const pushToggle = document.getElementById('pushToggle');
                
                if (enabled) {
                    soundSetting.style.opacity = '1';
                    soundSetting.style.pointerEvents = 'auto';
                    pushSetting.style.opacity = '1';
                    pushSetting.style.pointerEvents = 'auto';
                } else {
                    soundSetting.style.opacity = '0.5';
                    soundSetting.style.pointerEvents = 'none';
                    pushSetting.style.opacity = '0.5';
                    pushSetting.style.pointerEvents = 'none';
                    soundToggle.checked = false;
                    pushToggle.checked = false;
                    this.soundEnabled = false;
                    this.pushEnabled = false;
                    localStorage.setItem('chatSoundEnabled', false);
                    localStorage.setItem('chatPushEnabled', false);
                }
            };
            
            document.getElementById('soundToggle').onchange = (e) => {
                this.soundEnabled = e.target.checked;
                localStorage.setItem('chatSoundEnabled', this.soundEnabled);
            };
            
            document.getElementById('pushToggle').onchange = async (e) => {
                if (e.target.checked) {
                    const permission = await Notification.requestPermission();
                    this.pushEnabled = permission === 'granted';
                    e.target.checked = this.pushEnabled;
                    
                    if (this.pushEnabled) {
                        // Tester la notification
                        const testNotification = new Notification('🔔 Notifications activées', {
                            body: 'Vous recevrez maintenant les notifications de chat sur mobile',
                            icon: '/Misterpips.jpg',
                            tag: 'test-notification',
                            vibrate: /Android/.test(navigator.userAgent) ? [100, 50, 100] : undefined
                        });
                        
                        setTimeout(() => testNotification.close(), 3000);
                    }
                } else {
                    this.pushEnabled = false;
                }
                localStorage.setItem('chatPushEnabled', this.pushEnabled);
                
                // Afficher un message d'aide pour iOS
                if (!this.pushEnabled && /iPad|iPhone|iPod/.test(navigator.userAgent)) {
                    setTimeout(() => {
                        alert('📱 Sur iOS: Pour recevoir les notifications, ajoutez ce site à votre écran d\'accueil via Safari > Partager > Sur l\'\u00e9cran d\'accueil');
                    }, 500);
                }
            };
            
            document.getElementById('changeNicknameBtn').onclick = () => {
                this.showNicknameModal();
            };
            
            document.getElementById('saveSettingsBtn').onclick = () => {
                this.loadMessages();
            };
        };
        
        VIPChat.prototype.getNotificationHelp = function() {
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            const isAndroid = /Android/.test(navigator.userAgent);
            
            if (isIOS) {
                return 'Sur iOS: Ajoutez le site à l\'\u00e9cran d\'accueil pour les notifications';
            } else if (isAndroid) {
                return 'Notifications push disponibles sur Android';
            } else {
                return 'Notifications disponibles sur mobile et en arrière-plan';
            }
        };
    </script>
</body>
</html>